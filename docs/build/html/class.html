

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Classes &mdash; Riner 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Functions" href="function.html" />
    <link rel="prev" title="Introduction" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #343131" >
          

          
            <a href="index.html">
          

          
            
            <img src="_static/img_logo_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started with Riner</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html#getting-started">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Api Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#poolrecords">PoolRecords</a></li>
<li class="toctree-l2"><a class="reference internal" href="#statisticnode">StatisticNode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#devicerecords">DeviceRecords</a></li>
<li class="toctree-l2"><a class="reference internal" href="#expaverage">ExpAverage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mean">Mean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#amdgpuapi">AmdgpuApi</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpuapi">GpuApi</a></li>
<li class="toctree-l2"><a class="reference internal" href="#barrier">Barrier</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamicbuffer">DynamicBuffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#locked">Locked</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lockguarded">LockGuarded</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sharedlockguarded">SharedLockGuarded</a></li>
<li class="toctree-l2"><a class="reference internal" href="#readlocked">ReadLocked</a></li>
<li class="toctree-l2"><a class="reference internal" href="#immediatelocked">ImmediateLocked</a></li>
<li class="toctree-l2"><a class="reference internal" href="#writelocked">WriteLocked</a></li>
<li class="toctree-l2"><a class="reference internal" href="#upgradeablelockguarded">UpgradeableLockGuarded</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hexstring">HexString</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lineio">LineIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#jsonio">JsonIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#jsonrpcio">JsonRpcIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#jsonrpcutil">JsonRpcUtil</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ioconnection">IOConnection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#baseio">BaseIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cxnhandle">CxnHandle</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iotypelayer">IOTypeLayer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#method">Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="#requestbuilder">RequestBuilder</a></li>
<li class="toctree-l2"><a class="reference internal" href="#socket">Socket</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algodummy">AlgoDummy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algorithm">Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#taskexecutorpool">TaskExecutorPool</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algocuckatoo31cl">AlgoCuckatoo31Cl</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dagfile">DagFile</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dagcachecontainer">DagCacheContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algoethashcl">AlgoEthashCL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#jsonserializable">JsonSerializable</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clprogramloader">CLProgramLoader</a></li>
<li class="toctree-l2"><a class="reference internal" href="#computemodule">ComputeModule</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deviceid">DeviceId</a></li>
<li class="toctree-l2"><a class="reference internal" href="#application">Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="#registry">Registry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#apiserver">ApiServer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#work">Work</a></li>
<li class="toctree-l2"><a class="reference internal" href="#worksolution">WorkSolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#workethash">WorkEthash</a></li>
<li class="toctree-l2"><a class="reference internal" href="#worksolutionethash">WorkSolutionEthash</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stillalivetrackable">StillAliveTrackable</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pool">Pool</a></li>
<li class="toctree-l2"><a class="reference internal" href="#workqueue">WorkQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lazyworkqueue">LazyWorkQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="#poolethashstratum">PoolEthashStratum</a></li>
<li class="toctree-l2"><a class="reference internal" href="#poolgrinstratum">PoolGrinStratum</a></li>
<li class="toctree-l2"><a class="reference internal" href="#poolswitcher">PoolSwitcher</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pooldummy">PoolDummy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dummytestpoolserver">DummyTestPoolServer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#workcuckoo">WorkCuckoo</a></li>
<li class="toctree-l2"><a class="reference internal" href="#worksolutioncuckoo">WorkSolutionCuckoo</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpuapiconstructionargs">GpuApiConstructionArgs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#has-value-type">has_value_type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parsepooladdressresult">ParsePoolAddressResult</a></li>
<li class="toctree-l2"><a class="reference internal" href="#makestr">MakeStr</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setthreadnamestream">SetThreadNameStream</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpusettings">GpuSettings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algosettings">AlgoSettings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#error">Error</a></li>
<li class="toctree-l2"><a class="reference internal" href="#response">Response</a></li>
<li class="toctree-l2"><a class="reference internal" href="#request">Request</a></li>
<li class="toctree-l2"><a class="reference internal" href="#message">Message</a></li>
<li class="toctree-l2"><a class="reference internal" href="#connection">Connection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ioconversionerror">IOConversionError</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ssldesc">SslDesc</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algoconstructionargs">AlgoConstructionArgs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pcieindex">PcieIndex</a></li>
<li class="toctree-l2"><a class="reference internal" href="#device">Device</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shutdownstate">ShutdownState</a></li>
<li class="toctree-l2"><a class="reference internal" href="#commandlineargs">CommandLineArgs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#haspowtypeethash">HasPowTypeEthash</a></li>
<li class="toctree-l2"><a class="reference internal" href="#poolconstructionargs">PoolConstructionArgs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pooljob">PoolJob</a></li>
<li class="toctree-l2"><a class="reference internal" href="#haspowtypedummy">HasPowTypeDummy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#workdummy">WorkDummy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#worksolutiondummy">WorkSolutionDummy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ethashstratumjob">EthashStratumJob</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grinstratumjob">GrinStratumJob</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dummypooljob">DummyPoolJob</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="function.html">Functions</a></li>
</ul>
<p class="caption"><span class="caption-text">Licensing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Riner</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/class.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="classes">
<h1>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="poolrecords">
<h2>PoolRecords<a class="headerlink" href="#poolrecords" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner11PoolRecordsE">
<span id="_CPPv3N5riner11PoolRecordsE"></span><span id="_CPPv2N5riner11PoolRecordsE"></span><span id="riner::PoolRecords"></span><span class="target" id="classriner_1_1PoolRecords"></span><em class="property">class </em><code class="sig-name descname">PoolRecords</code><a class="headerlink" href="#_CPPv4N5riner11PoolRecordsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>class for gathering statistics per pool connection XRecords types are wired in a tree structure that aggregates their statistics data. The tree structure is created via the <code class="docutils literal notranslate"><span class="pre">XRecords(XRecords</span> <span class="pre">&amp;parent)</span></code> constructor</p>
<p>The layout of this class is similar to <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1DeviceRecords"><span class="std std-ref"><span class="pre">DeviceRecords</span></span></a></code>. see <code class="docutils literal notranslate"><span class="pre">DeviceRecords.h</span></code> for more documentation </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner11PoolRecords11reportShareEdbb">
<span id="_CPPv3N5riner11PoolRecords11reportShareEdbb"></span><span id="_CPPv2N5riner11PoolRecords11reportShareEdbb"></span><span id="riner::PoolRecords::reportShare__double.b.b"></span><span class="target" id="classriner_1_1PoolRecords_1a39e2de0fdb2f58c9485b727a65a6e385"></span>void <code class="sig-name descname">reportShare</code><span class="sig-paren">(</span>double <em>difficulty</em>, bool <em>isAccepted</em>, bool <em>isDuplicate</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11PoolRecords11reportShareEdbb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call this method to report that a share of a certain difficulty was sent to the pool and whether the pool accepted it (and whether it was a duplicate or not) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11PoolRecords13resetIntervalEv">
<span id="_CPPv3N5riner11PoolRecords13resetIntervalEv"></span><span id="_CPPv2N5riner11PoolRecords13resetIntervalEv"></span><span id="riner::PoolRecords::resetInterval"></span><span class="target" id="classriner_1_1PoolRecords_1a188191697c2650548a48f17036d551cd"></span>void <code class="sig-name descname">resetInterval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11PoolRecords13resetIntervalEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reset the averaging intervals of <a class="reference internal" href="#structriner_1_1PoolRecords_1_1Data"><span class="std std-ref">Data</span></a>’s members for all listeners </p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv4N5riner11PoolRecords4DataE">
<span id="_CPPv3N5riner11PoolRecords4DataE"></span><span id="_CPPv2N5riner11PoolRecords4DataE"></span><span id="riner::PoolRecords::Data"></span><span class="target" id="structriner_1_1PoolRecords_1_1Data"></span><em class="property">struct </em><code class="sig-name descname">Data</code><a class="headerlink" href="#_CPPv4N5riner11PoolRecords4DataE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5riner11PoolRecords4Data18connectionDurationEv">
<span id="_CPPv3NK5riner11PoolRecords4Data18connectionDurationEv"></span><span id="_CPPv2NK5riner11PoolRecords4Data18connectionDurationEv"></span><span id="riner::PoolRecords::Data::connectionDurationC"></span><span class="target" id="structriner_1_1PoolRecords_1_1Data_1a0e6a5f1fa0eb9b10afec692ba5375303"></span>clock::duration <code class="sig-name descname">connectionDuration</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner11PoolRecords4Data18connectionDurationEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns a pool connection duration estimate based on accepted shares time interval </p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="statisticnode">
<h2>StatisticNode<a class="headerlink" href="#statisticnode" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I0EN5riner13StatisticNodeE">
<span id="_CPPv3I0EN5riner13StatisticNodeE"></span><span id="_CPPv2I0EN5riner13StatisticNodeE"></span><span class="target" id="classriner_1_1StatisticNode"></span>template&lt;class <code class="sig-name descname">T</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">StatisticNode</code><a class="headerlink" href="#_CPPv4I0EN5riner13StatisticNodeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>helper class for propagating changes to T (which contains statistic data) along a listener chain. This means that, e.g. there is a <a class="reference internal" href="#classriner_1_1StatisticNode"><span class="std std-ref">StatisticNode</span></a> for every Gpu, but also a <a class="reference internal" href="#classriner_1_1StatisticNode"><span class="std std-ref">StatisticNode</span></a> that gathers information from all of the Gpu’s individual nodes and aggregates their data. This is mostly done by using the public lockedForEach and lockedApply </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner13StatisticNode13lockedForEachERRNSt8functionIFvR1TEEE">
<span id="_CPPv3N5riner13StatisticNode13lockedForEachERRNSt8functionIFvR1TEEE"></span><span id="_CPPv2N5riner13StatisticNode13lockedForEachERRNSt8functionIFvR1TEEE"></span><span class="target" id="classriner_1_1StatisticNode_1a255b917ead1cfb24620f526e58d29f5e"></span>void <code class="sig-name descname">lockedForEach</code><span class="sig-paren">(</span>std::function&lt;void<span class="sig-paren">(</span>T&amp;<span class="sig-paren">)</span>&gt; &amp;&amp;<em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13StatisticNode13lockedForEachERRNSt8functionIFvR1TEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use this function to modify the T instance of this node and all child nodes by the same func. !!! DEADLOCK possible! this function holds a lock while calling a callback! be careful! </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13StatisticNode11lockedApplyERRNSt8functionIFvR1TEEE">
<span id="_CPPv3N5riner13StatisticNode11lockedApplyERRNSt8functionIFvR1TEEE"></span><span id="_CPPv2N5riner13StatisticNode11lockedApplyERRNSt8functionIFvR1TEEE"></span><span class="target" id="classriner_1_1StatisticNode_1aad915b2e1cd29baecbe45c5c4017609f"></span>void <code class="sig-name descname">lockedApply</code><span class="sig-paren">(</span>std::function&lt;void<span class="sig-paren">(</span>T&amp;<span class="sig-paren">)</span>&gt; &amp;&amp;<em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13StatisticNode11lockedApplyERRNSt8functionIFvR1TEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use this function in case you want to modify the T instance of this particular node but don’t want a copy operation to happen, otherwise call <a class="reference internal" href="#classriner_1_1StatisticNode_1a33f62997bd56d7c3415b72c665770ebc"><span class="std std-ref">getValue()</span></a> !!! DEADLOCK possible! this function holds a lock while calling a callback! be careful! </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner13StatisticNode11lockedApplyERRNSt8functionIFvRK1TEEE">
<span id="_CPPv3NK5riner13StatisticNode11lockedApplyERRNSt8functionIFvRK1TEEE"></span><span id="_CPPv2NK5riner13StatisticNode11lockedApplyERRNSt8functionIFvRK1TEEE"></span><span class="target" id="classriner_1_1StatisticNode_1a93d08279e3e672753162f20b7deab27a"></span>void <code class="sig-name descname">lockedApply</code><span class="sig-paren">(</span>std::function&lt;void<span class="sig-paren">(</span><em class="property">const</em> T&amp;<span class="sig-paren">)</span>&gt; &amp;&amp;<em>func</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner13StatisticNode11lockedApplyERRNSt8functionIFvRK1TEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use this function in case you want to read the T instance of this particular node but don’t want a copy operation to happen, otherwise call <a class="reference internal" href="#classriner_1_1StatisticNode_1a33f62997bd56d7c3415b72c665770ebc"><span class="std std-ref">getValue()</span></a> !!! DEADLOCK possible! this function holds a lock while calling a callback! be careful! </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner13StatisticNode8getValueEv">
<span id="_CPPv3NK5riner13StatisticNode8getValueEv"></span><span id="_CPPv2NK5riner13StatisticNode8getValueEv"></span><span id="riner::StatisticNode::getValueC"></span><span class="target" id="classriner_1_1StatisticNode_1a33f62997bd56d7c3415b72c665770ebc"></span>T <code class="sig-name descname">getValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner13StatisticNode8getValueEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a copy of the T instance of this node </p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv4N5riner13StatisticNode4NodeE">
<span id="_CPPv3N5riner13StatisticNode4NodeE"></span><span id="_CPPv2N5riner13StatisticNode4NodeE"></span><span id="riner::StatisticNode::Node"></span><span class="target" id="structriner_1_1StatisticNode_1_1Node"></span><em class="property">struct </em><code class="sig-name descname">Node</code><a class="headerlink" href="#_CPPv4N5riner13StatisticNode4NodeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>this Node class is just a wrapper so the entire thing can be put into a std::shared_ptr, which allows std::weak_ptr functionality (figuring out whether the instance was deleted) </p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="devicerecords">
<h2>DeviceRecords<a class="headerlink" href="#devicerecords" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner13DeviceRecordsE">
<span id="_CPPv3N5riner13DeviceRecordsE"></span><span id="_CPPv2N5riner13DeviceRecordsE"></span><span id="riner::DeviceRecords"></span><span class="target" id="classriner_1_1DeviceRecords"></span><em class="property">class </em><code class="sig-name descname">DeviceRecords</code><a class="headerlink" href="#_CPPv4N5riner13DeviceRecordsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>class for gathering statistics per compute device (e.g. per GPU) XRecords types are wired in a tree structure that aggregates their statistics data. The tree structure is created via the <code class="docutils literal notranslate"><span class="pre">XRecords(XRecords</span> <span class="pre">&amp;parent)</span></code> constructor </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner13DeviceRecords13DeviceRecordsERR13DeviceRecords">
<span id="_CPPv3N5riner13DeviceRecords13DeviceRecordsERR13DeviceRecords"></span><span id="_CPPv2N5riner13DeviceRecords13DeviceRecordsERR13DeviceRecords"></span><span id="riner::DeviceRecords::DeviceRecords__DeviceRecordsRR"></span><span class="target" id="classriner_1_1DeviceRecords_1ab2c160efdb979fe52b1d2883636786a7"></span><code class="sig-name descname">DeviceRecords</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5riner13DeviceRecords13DeviceRecordsERR13DeviceRecords" title="riner::DeviceRecords::DeviceRecords">DeviceRecords</a>&amp;&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13DeviceRecords13DeviceRecordsERR13DeviceRecords" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>regular move constructor, nothing different here. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13DeviceRecords13DeviceRecordsER13DeviceRecords">
<span id="_CPPv3N5riner13DeviceRecords13DeviceRecordsER13DeviceRecords"></span><span id="_CPPv2N5riner13DeviceRecords13DeviceRecordsER13DeviceRecords"></span><span id="riner::DeviceRecords::DeviceRecords__DeviceRecordsR"></span><span class="target" id="classriner_1_1DeviceRecords_1a43b7a15f9804d6c235e70a07b3b21641"></span><code class="sig-name descname">DeviceRecords</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5riner13DeviceRecords13DeviceRecordsERR13DeviceRecords" title="riner::DeviceRecords::DeviceRecords">DeviceRecords</a> &amp;<em>parentListening</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13DeviceRecords13DeviceRecordsER13DeviceRecords" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>this is not a copy constructor, its just a constructor that uses the listening parent to initialize </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner13DeviceRecords4readEv">
<span id="_CPPv3NK5riner13DeviceRecords4readEv"></span><span id="_CPPv2NK5riner13DeviceRecords4readEv"></span><span id="riner::DeviceRecords::readC"></span><span class="target" id="classriner_1_1DeviceRecords_1a9c58fc943f67b6685d71de66d208f079"></span><a class="reference internal" href="#_CPPv4N5riner13DeviceRecordsE" title="riner::DeviceRecords">DeviceRecords</a>::<a class="reference internal" href="#_CPPv4N5riner13DeviceRecords4DataE" title="riner::DeviceRecords::Data">Data</a> <code class="sig-name descname">read</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner13DeviceRecords4readEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reads the current state of the statistics data and copies it out </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13DeviceRecords25reportScannedNoncesAmountE8uint64_t">
<span id="_CPPv3N5riner13DeviceRecords25reportScannedNoncesAmountE8uint64_t"></span><span id="_CPPv2N5riner13DeviceRecords25reportScannedNoncesAmountE8uint64_t"></span><span id="riner::DeviceRecords::reportScannedNoncesAmount__uint64_t"></span><span class="target" id="classriner_1_1DeviceRecords_1ab5176f1e790fbe0cf73be36e015cbff1"></span>void <code class="sig-name descname">reportScannedNoncesAmount</code><span class="sig-paren">(</span>uint64_t <em>scannedNonces</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13DeviceRecords25reportScannedNoncesAmountE8uint64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call this whenever your algo finished traversing a bunch of nonces this is what the hashrate will get derived from </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13DeviceRecords14reportWorkUnitEdb">
<span id="_CPPv3N5riner13DeviceRecords14reportWorkUnitEdb"></span><span id="_CPPv2N5riner13DeviceRecords14reportWorkUnitEdb"></span><span id="riner::DeviceRecords::reportWorkUnit__double.b"></span><span class="target" id="classriner_1_1DeviceRecords_1aa64f618d11218478538edfdff9312f5e"></span>void <code class="sig-name descname">reportWorkUnit</code><span class="sig-paren">(</span>double <em>difficulty</em>, bool <em>valid</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13DeviceRecords14reportWorkUnitEdb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call this when a solution of your algorithm was found that was verified by the CPU. if the solution is valid matching e.g. deviceDifficulty, then the valid flag needs to be set. a hardware error or a software bug might produce an invalid solution and the valid flag must be cleared for invalid solutions </p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv4N5riner13DeviceRecords7AverageE">
<span id="_CPPv3N5riner13DeviceRecords7AverageE"></span><span id="_CPPv2N5riner13DeviceRecords7AverageE"></span><span id="riner::DeviceRecords::Average"></span><span class="target" id="structriner_1_1DeviceRecords_1_1Average"></span><em class="property">struct </em><code class="sig-name descname">Average</code><a class="headerlink" href="#_CPPv4N5riner13DeviceRecords7AverageE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner13DeviceRecords7Average9addRecordEdN5clock10time_pointE">
<span id="_CPPv3N5riner13DeviceRecords7Average9addRecordEdN5clock10time_pointE"></span><span id="_CPPv2N5riner13DeviceRecords7Average9addRecordEdN5clock10time_pointE"></span><span id="riner::DeviceRecords::Average::addRecord__double.clock::time_point"></span><span class="target" id="structriner_1_1DeviceRecords_1_1Average_1ab3bde9a2e4fa63ab54c74945913e219b"></span>void <code class="sig-name descname">addRecord</code><span class="sig-paren">(</span>double <em>val</em>, clock::time_point <em>t</em> = clock::now()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13DeviceRecords7Average9addRecordEdN5clock10time_pointE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a Record and propagate it to the contained <a class="reference internal" href="#classriner_1_1Mean"><span class="std std-ref">Mean</span></a> and <a class="reference internal" href="#classriner_1_1ExpAverage"><span class="std std-ref">ExpAverage</span></a> objects </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5riner13DeviceRecords4DataE">
<span id="_CPPv3N5riner13DeviceRecords4DataE"></span><span id="_CPPv2N5riner13DeviceRecords4DataE"></span><span id="riner::DeviceRecords::Data"></span><span class="target" id="structriner_1_1DeviceRecords_1_1Data"></span><em class="property">struct </em><code class="sig-name descname">Data</code><a class="headerlink" href="#_CPPv4N5riner13DeviceRecords4DataE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>actual statistics that are being tracked see reportX methods for more details </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5riner13DeviceRecords12NonceAverageE">
<span id="_CPPv3N5riner13DeviceRecords12NonceAverageE"></span><span id="_CPPv2N5riner13DeviceRecords12NonceAverageE"></span><span id="riner::DeviceRecords::NonceAverage"></span><span class="target" id="structriner_1_1DeviceRecords_1_1NonceAverage"></span><em class="property">struct </em><code class="sig-name descname">NonceAverage</code><a class="headerlink" href="#_CPPv4N5riner13DeviceRecords12NonceAverageE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner13DeviceRecords12NonceAverage9addRecordEdN5clock10time_pointE">
<span id="_CPPv3N5riner13DeviceRecords12NonceAverage9addRecordEdN5clock10time_pointE"></span><span id="_CPPv2N5riner13DeviceRecords12NonceAverage9addRecordEdN5clock10time_pointE"></span><span id="riner::DeviceRecords::NonceAverage::addRecord__double.clock::time_point"></span><span class="target" id="structriner_1_1DeviceRecords_1_1NonceAverage_1adda0e133c59b1342bd0fbaec79a64042"></span>void <code class="sig-name descname">addRecord</code><span class="sig-paren">(</span>double <em>val</em>, clock::time_point <em>t</em> = clock::now()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13DeviceRecords12NonceAverage9addRecordEdN5clock10time_pointE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a Record and propagate it to the contained <a class="reference internal" href="#classriner_1_1Mean"><span class="std std-ref">Mean</span></a> and <a class="reference internal" href="#classriner_1_1ExpAverage"><span class="std std-ref">ExpAverage</span></a> objects </p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="expaverage">
<h2>ExpAverage<a class="headerlink" href="#expaverage" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner10ExpAverageE">
<span id="_CPPv3N5riner10ExpAverageE"></span><span id="_CPPv2N5riner10ExpAverageE"></span><span id="riner::ExpAverage"></span><span class="target" id="classriner_1_1ExpAverage"></span><em class="property">class </em><code class="sig-name descname">ExpAverage</code><a class="headerlink" href="#_CPPv4N5riner10ExpAverageE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>running Exponential Average class used by statistics objects use addRecord to add additional data points and getRate() or getWeightRate() for reading results </p>
</dd></dl>

</div>
<div class="section" id="mean">
<h2>Mean<a class="headerlink" href="#mean" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4MeanE">
<span id="_CPPv3N5riner4MeanE"></span><span id="_CPPv2N5riner4MeanE"></span><span id="riner::Mean"></span><span class="target" id="classriner_1_1Mean"></span><em class="property">class </em><code class="sig-name descname">Mean</code><a class="headerlink" href="#_CPPv4N5riner4MeanE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>running mean class used by statistics objects use addRecord to add additional data points and getRate() or getWeightRate() for reading results </p>
</dd></dl>

</div>
<div class="section" id="amdgpuapi">
<h2>AmdgpuApi<a class="headerlink" href="#amdgpuapi" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9AmdgpuApiE">
<span id="_CPPv3N5riner9AmdgpuApiE"></span><span id="_CPPv2N5riner9AmdgpuApiE"></span><span id="riner::AmdgpuApi"></span><span class="target" id="classriner_1_1AmdgpuApi"></span><em class="property">class </em><code class="sig-name descname">AmdgpuApi</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner6GpuApiE" title="riner::GpuApi">GpuApi</a><a class="headerlink" href="#_CPPv4N5riner9AmdgpuApiE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner9AmdgpuApi7tryMakeERK22GpuApiConstructionArgs">
<span id="_CPPv3N5riner9AmdgpuApi7tryMakeERK22GpuApiConstructionArgs"></span><span id="_CPPv2N5riner9AmdgpuApi7tryMakeERK22GpuApiConstructionArgs"></span><span id="riner::AmdgpuApi::tryMake__GpuApiConstructionArgsCR"></span><span class="target" id="classriner_1_1AmdgpuApi_1af9500e6b9fc7198fabdb67842fe42a67"></span>std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner6GpuApiE" title="riner::GpuApi">GpuApi</a>&gt; <code class="sig-name descname">tryMake</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner22GpuApiConstructionArgsE" title="riner::GpuApiConstructionArgs">GpuApiConstructionArgs</a> &amp;<em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9AmdgpuApi7tryMakeERK22GpuApiConstructionArgs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tries to instantiate <a class="reference internal" href="#classriner_1_1AmdgpuApi"><span class="std std-ref">AmdgpuApi</span></a> and if the API is not available, then nullptr is returned </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="gpuapi">
<h2>GpuApi<a class="headerlink" href="#gpuapi" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner6GpuApiE">
<span id="_CPPv3N5riner6GpuApiE"></span><span id="_CPPv2N5riner6GpuApiE"></span><span id="riner::GpuApi"></span><span class="target" id="classriner_1_1GpuApi"></span><em class="property">class </em><code class="sig-name descname">GpuApi</code><a class="headerlink" href="#_CPPv4N5riner6GpuApiE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for GpuApis that allow reading or writing of voltage/Fanspeed etc… </p>
<p>Subclassed by <a class="reference internal" href="#classriner_1_1AmdgpuApi"><span class="std std-ref">riner::AmdgpuApi</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner6GpuApi9tryCreateERK22GpuApiConstructionArgs">
<span id="_CPPv3N5riner6GpuApi9tryCreateERK22GpuApiConstructionArgs"></span><span id="_CPPv2N5riner6GpuApi9tryCreateERK22GpuApiConstructionArgs"></span><span id="riner::GpuApi::tryCreate__GpuApiConstructionArgsCR"></span><span class="target" id="classriner_1_1GpuApi_1a1e176c9db2bdfeaebbb63043f2fbb559"></span>std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner6GpuApiE" title="riner::GpuApi">GpuApi</a>&gt; <code class="sig-name descname">tryCreate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner22GpuApiConstructionArgsE" title="riner::GpuApiConstructionArgs">GpuApiConstructionArgs</a> &amp;<em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner6GpuApi9tryCreateERK22GpuApiConstructionArgs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>factory to instantiate a derived <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> class. If no API is available, then nullptr is returned internally DerivedClass::tryMake is called for each DerivedClass registered with GpuApi::Registry&lt;DerivedClass&gt;() while DerivedClass::tryMake returns nullptr </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="barrier">
<h2>Barrier<a class="headerlink" href="#barrier" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner7BarrierE">
<span id="_CPPv3N5riner7BarrierE"></span><span id="_CPPv2N5riner7BarrierE"></span><span id="riner::Barrier"></span><span class="target" id="classriner_1_1Barrier"></span><em class="property">class </em><code class="sig-name descname">Barrier</code><a class="headerlink" href="#_CPPv4N5riner7BarrierE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>a barrier object that multiple threads can <a class="reference internal" href="#classriner_1_1Barrier_1a557a852705b5384f3aae89c79bf09b39"><span class="std std-ref">wait()</span></a> on until another thread calls <a class="reference internal" href="#classriner_1_1Barrier_1a2811bd2e9acdf7b526894ec1700ae1a1"><span class="std std-ref">unblock()</span></a>. not designed for efficiency. Used for writing tests </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5riner7Barrier4waitEv">
<span id="_CPPv3NK5riner7Barrier4waitEv"></span><span id="_CPPv2NK5riner7Barrier4waitEv"></span><span id="riner::Barrier::waitC"></span><span class="target" id="classriner_1_1Barrier_1a557a852705b5384f3aae89c79bf09b39"></span>void <code class="sig-name descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner7Barrier4waitEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait from one or more threads (no spurious wakes) see std::shared_future documentation for specifics </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner7Barrier8wait_forENSt6chrono12millisecondsE">
<span id="_CPPv3NK5riner7Barrier8wait_forENSt6chrono12millisecondsE"></span><span id="_CPPv2NK5riner7Barrier8wait_forENSt6chrono12millisecondsE"></span><span id="riner::Barrier::wait_for__std::chrono::millisecondsC"></span><span class="target" id="classriner_1_1Barrier_1aae7edae7f1933aa39d6363b00106a74c"></span>std::future_status <code class="sig-name descname">wait_for</code><span class="sig-paren">(</span>std::chrono::milliseconds <em>duration</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner7Barrier8wait_forENSt6chrono12millisecondsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait from one or more threads with timeout (no spurious wakes) <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>value can be used to find out if timeout happened see std::shared_future documentation for specifics </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner7Barrier7unblockEv">
<span id="_CPPv3N5riner7Barrier7unblockEv"></span><span id="_CPPv2N5riner7Barrier7unblockEv"></span><span id="riner::Barrier::unblock"></span><span class="target" id="classriner_1_1Barrier_1a2811bd2e9acdf7b526894ec1700ae1a1"></span>void <code class="sig-name descname">unblock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner7Barrier7unblockEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lets the threads waiting at <a class="reference internal" href="#classriner_1_1Barrier_1a557a852705b5384f3aae89c79bf09b39"><span class="std std-ref">wait()</span></a> continue. after calling this, <a class="reference internal" href="#classriner_1_1Barrier_1a557a852705b5384f3aae89c79bf09b39"><span class="std std-ref">wait()</span></a> returns immediately see std::promise documentation for specifics </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="dynamicbuffer">
<h2>DynamicBuffer<a class="headerlink" href="#dynamicbuffer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I0EN5riner13DynamicBufferE">
<span id="_CPPv3I0EN5riner13DynamicBufferE"></span><span id="_CPPv2I0EN5riner13DynamicBufferE"></span><span class="target" id="classriner_1_1DynamicBuffer"></span>template&lt;class <code class="sig-name descname">T</code> = uint8_t&gt;<br /><em class="property">class </em><code class="sig-name descname">DynamicBuffer</code><a class="headerlink" href="#_CPPv4I0EN5riner13DynamicBufferE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>simple replacement for std::vector&lt;char&gt; in situations where huge allocations happen, since the standard doesn’t define how much more memory std::vector allocates on reserve or resize.</p>
<p>basically an owning gsl::span </p>
</dd></dl>

</div>
<div class="section" id="locked">
<h2>Locked<a class="headerlink" href="#locked" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I00EN5riner6LockedE">
<span id="_CPPv3I00EN5riner6LockedE"></span><span id="_CPPv2I00EN5riner6LockedE"></span><span class="target" id="classriner_1_1Locked"></span>template&lt;class <code class="sig-name descname">T</code>, class <code class="sig-name descname">Lock</code> = std::unique_lock&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv4I00EN5riner6LockedE" title="riner::Locked::T">T</a>::mutex_type&gt;&gt;<br /><em class="property">class </em><code class="sig-name descname">Locked</code><a class="headerlink" href="#_CPPv4I00EN5riner6LockedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return type of <a class="reference internal" href="#classriner_1_1LockGuarded_1a8e0996284f837cc11d963d30da6d7cef"><span class="std std-ref">LockGuarded&lt;V&gt;::lock()</span></a> method <a class="reference internal" href="#classriner_1_1Locked"><span class="std std-ref">Locked</span></a> allows atomic access to an instance of V by locking a mutex. The lock is released upon the destruction of the <a class="reference internal" href="#classriner_1_1Locked"><span class="std std-ref">Locked</span></a> instance. It’s mainly used as the return type of <a class="reference internal" href="#classriner_1_1LockGuarded_1a8e0996284f837cc11d963d30da6d7cef"><span class="std std-ref">LockGuarded&lt;V&gt;::lock()</span></a> method. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: the LockGuarded&lt;V&gt; that generated this instance via its lock() method </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Lock</span></code>: the underlying mutex ownership wrapper used to provide the locking functionality </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="lockguarded">
<h2>LockGuarded<a class="headerlink" href="#lockguarded" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I00EN5riner11LockGuardedE">
<span id="_CPPv3I00EN5riner11LockGuardedE"></span><span id="_CPPv2I00EN5riner11LockGuardedE"></span><span class="target" id="classriner_1_1LockGuarded"></span>template&lt;class <code class="sig-name descname">T</code>, class <code class="sig-name descname">Mutex</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">LockGuarded</code><a class="headerlink" href="#_CPPv4I00EN5riner11LockGuardedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper around an instance t of T that is only exclusively and atomically accessible after acquiring a lock. <a class="reference internal" href="#classriner_1_1LockGuarded"><span class="std std-ref">LockGuarded</span></a> contains an instance t that is associated with a mutex. t is only accessible via the object returned by the <a class="reference internal" href="#classriner_1_1LockGuarded_1a8e0996284f837cc11d963d30da6d7cef"><span class="std std-ref">lock()</span></a> medhod, which returns an object of type Locked&lt;…&gt;. This Locked&lt;…&gt; object acts as a RAII-style lock guard locking the mutex, but also provides operator-&gt; and operator* for accessing the instance t. This was inspired by lock_guard and the mutex&lt;T&gt; type of the rust language. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: type of the instance which is to be protected by the mutex </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Mutex</span></code>: the underlying mutex implementation used to provide the locking functionality </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5riner11LockGuarded4lockEv">
<span id="_CPPv3NK5riner11LockGuarded4lockEv"></span><span id="_CPPv2NK5riner11LockGuarded4lockEv"></span><span id="riner::LockGuarded::lockC"></span><span class="target" id="classriner_1_1LockGuarded_1a5a60d84dcc7a9527c13fdb1c6deee47d"></span>auto <code class="sig-name descname">lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner11LockGuarded4lockEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Locked&lt;…&gt; that allows access to only the const interface of the wrapped T via operator* and -&gt; </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11LockGuarded4lockEv">
<span id="_CPPv3N5riner11LockGuarded4lockEv"></span><span id="_CPPv2N5riner11LockGuarded4lockEv"></span><span id="riner::LockGuarded::lock"></span><span class="target" id="classriner_1_1LockGuarded_1a8e0996284f837cc11d963d30da6d7cef"></span>auto <code class="sig-name descname">lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11LockGuarded4lockEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Locked&lt;…&gt; that allows access to the wrapped T via operator* and -&gt; </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="sharedlockguarded">
<h2>SharedLockGuarded<a class="headerlink" href="#sharedlockguarded" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I00EN5riner17SharedLockGuardedE">
<span id="_CPPv3I00EN5riner17SharedLockGuardedE"></span><span id="_CPPv2I00EN5riner17SharedLockGuardedE"></span><span class="target" id="classriner_1_1SharedLockGuarded"></span>template&lt;class <code class="sig-name descname">T</code>, class <code class="sig-name descname">SharedMutex</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">SharedLockGuarded</code> : <em class="property">public</em> riner::LockGuarded&lt;<a class="reference internal" href="#_CPPv4I00EN5riner17SharedLockGuardedE" title="riner::SharedLockGuarded::T">T</a>, <a class="reference internal" href="#_CPPv4I00EN5riner17SharedLockGuardedE" title="riner::SharedLockGuarded::SharedMutex">SharedMutex</a>&gt;<a class="headerlink" href="#_CPPv4I00EN5riner17SharedLockGuardedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper around an instance t of T which provides either exclusive read/write or shared read only access to the instance t The object returned by the <a class="reference internal" href="#classriner_1_1LockGuarded_1a8e0996284f837cc11d963d30da6d7cef"><span class="std std-ref">lock()</span></a> method acquires exclusive lock and t can be read and written through it. The method readLock() aquires a shared lock and t can be accessed read only through the returned object. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: type of the instance which is to be protected by a shared mutex </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SharedMutex</span></code>: the underlying shared mutex implementation used to provide the locking functionality </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="readlocked">
<h2>ReadLocked<a class="headerlink" href="#readlocked" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I00EN5riner10ReadLockedE">
<span id="_CPPv3I00EN5riner10ReadLockedE"></span><span id="_CPPv2I00EN5riner10ReadLockedE"></span><span class="target" id="classriner_1_1ReadLocked"></span>template&lt;class <code class="sig-name descname">T</code>, class <code class="sig-name descname">SharedMutex</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">ReadLocked</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4I00EN5riner6LockedE" title="riner::Locked">Locked</a>&lt;<em class="property">const</em> UpgradeableLockGuarded&lt;<a class="reference internal" href="#_CPPv4I00EN5riner10ReadLockedE" title="riner::ReadLocked::T">T</a>, <a class="reference internal" href="#_CPPv4I00EN5riner10ReadLockedE" title="riner::ReadLocked::SharedMutex">SharedMutex</a>&gt;, std::shared_lock&lt;<a class="reference internal" href="#_CPPv4I00EN5riner10ReadLockedE" title="riner::ReadLocked::SharedMutex">SharedMutex</a>&gt;&gt;<a class="headerlink" href="#_CPPv4I00EN5riner10ReadLockedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Provides (shared) atomic, read only access to a wrapped instance of T. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: type of the instance which is to be protected by a shared mutex </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SharedMutex</span></code>: the underlying shared mutex implementation used to provide the locking functionality </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner10ReadLocked7upgradeEv">
<span id="_CPPv3N5riner10ReadLocked7upgradeEv"></span><span id="_CPPv2N5riner10ReadLocked7upgradeEv"></span><span id="riner::ReadLocked::upgrade"></span><span class="target" id="classriner_1_1ReadLocked_1aab2e7a8285fb68aab259f12de5cd0ae0"></span>WriteLocked&lt;T, SharedMutex&gt; <code class="sig-name descname">upgrade</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner10ReadLocked7upgradeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>moves object Dangerous: can cause a deadlock when used together with UpgradeableLockGuarded::lock() </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>WriteLocked&lt;T, SharedMutex&gt; through which the instance t can be accessed read only </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="immediatelocked">
<h2>ImmediateLocked<a class="headerlink" href="#immediatelocked" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I00EN5riner15ImmediateLockedE">
<span id="_CPPv3I00EN5riner15ImmediateLockedE"></span><span id="_CPPv2I00EN5riner15ImmediateLockedE"></span><span class="target" id="classriner_1_1ImmediateLocked"></span>template&lt;class <code class="sig-name descname">T</code>, class <code class="sig-name descname">SharedMutex</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">ImmediateLocked</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4I00EN5riner6LockedE" title="riner::Locked">Locked</a>&lt;<em class="property">const</em> UpgradeableLockGuarded&lt;<a class="reference internal" href="#_CPPv4I00EN5riner15ImmediateLockedE" title="riner::ImmediateLocked::T">T</a>, <a class="reference internal" href="#_CPPv4I00EN5riner15ImmediateLockedE" title="riner::ImmediateLocked::SharedMutex">SharedMutex</a>&gt;, std::shared_lock&lt;<a class="reference internal" href="#_CPPv4I00EN5riner15ImmediateLockedE" title="riner::ImmediateLocked::SharedMutex">SharedMutex</a>&gt;&gt;<a class="headerlink" href="#_CPPv4I00EN5riner15ImmediateLockedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Provides (shared) atomic, read only access to a wrapped instance of T, which can be upgraded atomically to (exclusive) read/write access Please note that instances of this class should be downgraded to read locks or upgraded to write locks as soon as possible because additional read locks cannot be aquired during the lifetime of this object. After requesting a write lock no other locks can be acquired, which means that the write lock will be acquired as soon as possible. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: type of the instance which is to be protected by a shared mutex </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SharedMutex</span></code>: the underlying shared mutex implementation used to provide the locking functionality </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner15ImmediateLocked7upgradeEv">
<span id="_CPPv3N5riner15ImmediateLocked7upgradeEv"></span><span id="_CPPv2N5riner15ImmediateLocked7upgradeEv"></span><span id="riner::ImmediateLocked::upgrade"></span><span class="target" id="classriner_1_1ImmediateLocked_1aad280388492ac92905ac3a30e3ac0591"></span>WriteLocked&lt;T, SharedMutex&gt; <code class="sig-name descname">upgrade</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15ImmediateLocked7upgradeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>moves object and atomically aquires unique access to the instance t </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>WriteLocked&lt;T, SharedMutex&gt; through which the instance t can be read or written </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner15ImmediateLocked9downgradeEv">
<span id="_CPPv3N5riner15ImmediateLocked9downgradeEv"></span><span id="_CPPv2N5riner15ImmediateLocked9downgradeEv"></span><span id="riner::ImmediateLocked::downgrade"></span><span class="target" id="classriner_1_1ImmediateLocked_1aa8f785b7bc5e04260125fdb9f978278b"></span>ReadLocked&lt;T, SharedMutex&gt; <code class="sig-name descname">downgrade</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15ImmediateLocked9downgradeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>moves object and acquires shared read only access to the instance t After calling the method other threads can get shared access to t again. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ReadLocked&lt;T, SharedMutex&gt; through which the instance t can be read only </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="writelocked">
<h2>WriteLocked<a class="headerlink" href="#writelocked" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I00EN5riner11WriteLockedE">
<span id="_CPPv3I00EN5riner11WriteLockedE"></span><span id="_CPPv2I00EN5riner11WriteLockedE"></span><span class="target" id="classriner_1_1WriteLocked"></span>template&lt;class <code class="sig-name descname">T</code>, class <code class="sig-name descname">SharedMutex</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">WriteLocked</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4I00EN5riner6LockedE" title="riner::Locked">Locked</a>&lt;UpgradeableLockGuarded&lt;<a class="reference internal" href="#_CPPv4I00EN5riner11WriteLockedE" title="riner::WriteLocked::T">T</a>, <a class="reference internal" href="#_CPPv4I00EN5riner11WriteLockedE" title="riner::WriteLocked::SharedMutex">SharedMutex</a>&gt;, std::unique_lock&lt;<a class="reference internal" href="#_CPPv4I00EN5riner11WriteLockedE" title="riner::WriteLocked::SharedMutex">SharedMutex</a>&gt;&gt;<a class="headerlink" href="#_CPPv4I00EN5riner11WriteLockedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Provides (exclusive) atomic, read/write access to a wrapped instance of T, which can be downgraded atomically to (shared) read only access. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: type of the instance which is to be protected by a shared mutex </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SharedMutex</span></code>: the underlying shared mutex implementation used to provide the locking functionality </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner11WriteLocked9downgradeEv">
<span id="_CPPv3N5riner11WriteLocked9downgradeEv"></span><span id="_CPPv2N5riner11WriteLocked9downgradeEv"></span><span id="riner::WriteLocked::downgrade"></span><span class="target" id="classriner_1_1WriteLocked_1aa30a89fe70db585f7b0ea9c1c50625ac"></span>ReadLocked&lt;T, SharedMutex&gt; <code class="sig-name descname">downgrade</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11WriteLocked9downgradeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>moves object and downgrades exclusive read/write access to shared read only access </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ReadLocked&lt;T, SharedMutex&gt; through which the instance t can be accessed read only </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="upgradeablelockguarded">
<h2>UpgradeableLockGuarded<a class="headerlink" href="#upgradeablelockguarded" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I00EN5riner22UpgradeableLockGuardedE">
<span id="_CPPv3I00EN5riner22UpgradeableLockGuardedE"></span><span id="_CPPv2I00EN5riner22UpgradeableLockGuardedE"></span><span class="target" id="classriner_1_1UpgradeableLockGuarded"></span>template&lt;class <code class="sig-name descname">T</code>, class <code class="sig-name descname">SharedMutex</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">UpgradeableLockGuarded</code><a class="headerlink" href="#_CPPv4I00EN5riner22UpgradeableLockGuardedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper around an instance t of T which provides either exclusive read/write or shared read only access to the instance t A similar class is <a class="reference internal" href="#classriner_1_1SharedLockGuarded"><span class="std std-ref">SharedLockGuarded</span></a>, but this class allows atomic upgrades or downgrades of locks, e.g. from shared read only access to exclusive read/write access. It has more overhead than the former class because it uses an additional mutex. Furthermore there are more guarantees that queued exclusive locks will be acquired before queued shared locks. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: type of the instance which is to be protected by a shared mutex </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SharedMutex</span></code>: the underlying shared mutex implementation used to provide the locking functionality </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5riner22UpgradeableLockGuarded4lockEv">
<span id="_CPPv3NK5riner22UpgradeableLockGuarded4lockEv"></span><span id="_CPPv2NK5riner22UpgradeableLockGuarded4lockEv"></span><span id="riner::UpgradeableLockGuarded::lockC"></span><span class="target" id="classriner_1_1UpgradeableLockGuarded_1aa1c21acce540daa6a8ab5c91aadce1c4"></span>WriteLocked&lt;T, SharedMutex&gt; <code class="sig-name descname">lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner22UpgradeableLockGuarded4lockEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>aquires exclusive write access to t, which can be downgraded to shared read only access later For details: refer to <a class="reference internal" href="#classriner_1_1WriteLocked"><span class="std std-ref">WriteLocked</span></a> </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>WriteLocked&lt;T, SharedMutex&gt; through which the instance t can be accessed </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner22UpgradeableLockGuarded13immediateLockEv">
<span id="_CPPv3NK5riner22UpgradeableLockGuarded13immediateLockEv"></span><span id="_CPPv2NK5riner22UpgradeableLockGuarded13immediateLockEv"></span><span id="riner::UpgradeableLockGuarded::immediateLockC"></span><span class="target" id="classriner_1_1UpgradeableLockGuarded_1a444c9f930ce81b6a738edc214983b06e"></span>ImmediateLocked&lt;T, SharedMutex&gt; <code class="sig-name descname">immediateLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner22UpgradeableLockGuarded13immediateLockEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>aquires shared read only access to t, which can be upgraded to exlusive read/write access later For details: refer to <a class="reference internal" href="#classriner_1_1ImmediateLocked"><span class="std std-ref">ImmediateLocked</span></a> </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ImmediateLocked&lt;T, SharedMutex&gt; through which the instance t can be accessed </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner22UpgradeableLockGuarded8readLockEv">
<span id="_CPPv3NK5riner22UpgradeableLockGuarded8readLockEv"></span><span id="_CPPv2NK5riner22UpgradeableLockGuarded8readLockEv"></span><span id="riner::UpgradeableLockGuarded::readLockC"></span><span class="target" id="classriner_1_1UpgradeableLockGuarded_1acf0577f350319791f93e42c2c5d6b9f1"></span>ReadLocked&lt;T, SharedMutex&gt; <code class="sig-name descname">readLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner22UpgradeableLockGuarded8readLockEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>aquires shared read only access to t </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ReadLocked&lt;T, SharedMutex&gt; through which the instance t can be accessed </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="hexstring">
<h2>HexString<a class="headerlink" href="#hexstring" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenclass: Cannot find class “riner::HexString” in doxygen xml output for project “Riner” from directory: ../xml/</p>
</div>
</div>
<div class="section" id="lineio">
<h2>LineIO<a class="headerlink" href="#lineio" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner6LineIOE">
<span id="_CPPv3N5riner6LineIOE"></span><span id="_CPPv2N5riner6LineIOE"></span><span id="riner::LineIO"></span><span class="target" id="classriner_1_1LineIO"></span><em class="property">class </em><code class="sig-name descname">LineIO</code> : <em class="property">public</em> riner::IOTypeLayer&lt;std::string, <a class="reference internal" href="#_CPPv4N5riner6BaseIOE" title="riner::BaseIO">BaseIO</a>&gt;<a class="headerlink" href="#_CPPv4N5riner6LineIOE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> for std::string lines, see <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> for more information.</p>
<p>since <a class="reference internal" href="#classriner_1_1BaseIO"><span class="std std-ref">BaseIO</span></a> already runs on <code class="docutils literal notranslate"><span class="pre">std::string</span></code> lines, this layer trivially takes the <code class="docutils literal notranslate"><span class="pre">std::string</span></code> from the layer below and passes it on to the next. If <a class="reference internal" href="#classriner_1_1BaseIO"><span class="std std-ref">BaseIO</span></a> is ever required to be refactored to work on another representation, this layer can still persist as a conversion to <code class="docutils literal notranslate"><span class="pre">std::string</span></code> lines for any implementations that may use its <code class="docutils literal notranslate"><span class="pre">setIncomingModifyFunc</span></code> or <code class="docutils literal notranslate"><span class="pre">setOutgoingModifyFunc</span></code> features. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner6LineIO15convertOutgoingENSt6stringE">
<span id="_CPPv3N5riner6LineIO15convertOutgoingENSt6stringE"></span><span id="_CPPv2N5riner6LineIO15convertOutgoingENSt6stringE"></span><span id="riner::LineIO::convertOutgoing__ss"></span><span class="target" id="classriner_1_1LineIO_1a6c3ddd9f38e354268942324a9f1952e8"></span>std::string <code class="sig-name descname">convertOutgoing</code><span class="sig-paren">(</span>std::string<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner6LineIO15convertOutgoingENSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>converts the outgoing type from this layer’s <code class="docutils literal notranslate"><span class="pre">T</span></code> to the type of the layer below. This function may throw an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1IOConversionError"><span class="std std-ref"><span class="pre">IOConversionError</span></span></a></code> if the conversion failed. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>successfully converted instance of <code class="docutils literal notranslate"><span class="pre">LayerBelowT</span></code> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer11IOTypeLayerEv">
<span id="_CPPv3N5riner11IOTypeLayer11IOTypeLayerEv"></span><span id="_CPPv2N5riner11IOTypeLayer11IOTypeLayerEv"></span><span id="riner::IOTypeLayer::IOTypeLayer"></span><span class="target" id="classriner_1_1LineIO_1a3627ad10b3a68341d76b5e1c5700209e"></span><code class="sig-name descname">IOTypeLayer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer11IOTypeLayerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor of the <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> does not establish any connection yet. Use <code class="docutils literal notranslate"><span class="pre">launchClient*()</span></code> or <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a19f932c9080f3b7097cbab5b57b6e807"><span class="std std-ref"><span class="pre">launchServer()</span></span></a></code> functions <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code>: not implemented yet </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="jsonio">
<h2>JsonIO<a class="headerlink" href="#jsonio" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner6JsonIOE">
<span id="_CPPv3N5riner6JsonIOE"></span><span id="_CPPv2N5riner6JsonIOE"></span><span id="riner::JsonIO"></span><span class="target" id="classriner_1_1JsonIO"></span><em class="property">class </em><code class="sig-name descname">JsonIO</code> : <em class="property">public</em> riner::IOTypeLayer&lt;nl::json, <a class="reference internal" href="#_CPPv4N5riner6LineIOE" title="riner::LineIO">LineIO</a>&gt;<a class="headerlink" href="#_CPPv4N5riner6JsonIOE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> for nl::json, see <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> for more information. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer11IOTypeLayerEv">
<span id="_CPPv3N5riner11IOTypeLayer11IOTypeLayerEv"></span><span id="_CPPv2N5riner11IOTypeLayer11IOTypeLayerEv"></span><span class="target" id="classriner_1_1JsonIO_1a3627ad10b3a68341d76b5e1c5700209e"></span><code class="sig-name descname">IOTypeLayer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Constructor of the <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> does not establish any connection yet. Use <code class="docutils literal notranslate"><span class="pre">launchClient*()</span></code> or <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a19f932c9080f3b7097cbab5b57b6e807"><span class="std std-ref"><span class="pre">launchServer()</span></span></a></code> functions <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code>: not implemented yet </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner6JsonIO15convertOutgoingEN2nl4jsonE">
<span id="_CPPv3N5riner6JsonIO15convertOutgoingEN2nl4jsonE"></span><span id="_CPPv2N5riner6JsonIO15convertOutgoingEN2nl4jsonE"></span><span id="riner::JsonIO::convertOutgoing__nl::json"></span><span class="target" id="classriner_1_1JsonIO_1acecf7419f4298af9ded68f36c2d4d540"></span>std::string <code class="sig-name descname">convertOutgoing</code><span class="sig-paren">(</span>nl::json<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner6JsonIO15convertOutgoingEN2nl4jsonE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>converts the outgoing type from this layer’s <code class="docutils literal notranslate"><span class="pre">T</span></code> to the type of the layer below. This function may throw an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1IOConversionError"><span class="std std-ref"><span class="pre">IOConversionError</span></span></a></code> if the conversion failed. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>successfully converted instance of <code class="docutils literal notranslate"><span class="pre">LayerBelowT</span></code> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="jsonrpcio">
<h2>JsonRpcIO<a class="headerlink" href="#jsonrpcio" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4jrpc9JsonRpcIOE">
<span id="_CPPv3N5riner4jrpc9JsonRpcIOE"></span><span id="_CPPv2N5riner4jrpc9JsonRpcIOE"></span><span id="riner::jrpc::JsonRpcIO"></span><span class="target" id="classriner_1_1jrpc_1_1JsonRpcIO"></span><em class="property">class </em><code class="sig-name descname">JsonRpcIO</code> : <em class="property">public</em> riner::IOTypeLayer&lt;<a class="reference internal" href="#_CPPv4N5riner4jrpc7MessageE" title="riner::jrpc::Message">Message</a>, <a class="reference internal" href="#_CPPv4N5riner6JsonIOE" title="riner::JsonIO">JsonIO</a>&gt;<a class="headerlink" href="#_CPPv4N5riner4jrpc9JsonRpcIOE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> for <a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref">jrpc::Message</span></a>, see <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> for more information. </p>
<p>Subclassed by <a class="reference internal" href="#classriner_1_1jrpc_1_1JsonRpcUtil"><span class="std std-ref">riner::jrpc::JsonRpcUtil</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer11IOTypeLayerEv">
<span id="_CPPv3N5riner11IOTypeLayer11IOTypeLayerEv"></span><span class="target" id="classriner_1_1jrpc_1_1JsonRpcIO_1a3627ad10b3a68341d76b5e1c5700209e"></span><code class="sig-name descname">IOTypeLayer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Constructor of the <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> does not establish any connection yet. Use <code class="docutils literal notranslate"><span class="pre">launchClient*()</span></code> or <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a19f932c9080f3b7097cbab5b57b6e807"><span class="std std-ref"><span class="pre">launchServer()</span></span></a></code> functions <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code>: not implemented yet </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner4jrpc9JsonRpcIO15convertOutgoingE7Message">
<span id="_CPPv3N5riner4jrpc9JsonRpcIO15convertOutgoingE7Message"></span><span id="_CPPv2N5riner4jrpc9JsonRpcIO15convertOutgoingE7Message"></span><span id="riner::jrpc::JsonRpcIO::convertOutgoing__Message"></span><span class="target" id="classriner_1_1jrpc_1_1JsonRpcIO_1a738a82c70c8a968d221aa4696a0aad28"></span>nl::json <code class="sig-name descname">convertOutgoing</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5riner4jrpc7MessageE" title="riner::jrpc::Message">Message</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc9JsonRpcIO15convertOutgoingE7Message" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>converts the outgoing type from this layer’s <code class="docutils literal notranslate"><span class="pre">T</span></code> to the type of the layer below. This function may throw an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1IOConversionError"><span class="std std-ref"><span class="pre">IOConversionError</span></span></a></code> if the conversion failed. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>successfully converted instance of <code class="docutils literal notranslate"><span class="pre">LayerBelowT</span></code> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="jsonrpcutil">
<h2>JsonRpcUtil<a class="headerlink" href="#jsonrpcutil" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4jrpc11JsonRpcUtilE">
<span id="_CPPv3N5riner4jrpc11JsonRpcUtilE"></span><span id="_CPPv2N5riner4jrpc11JsonRpcUtilE"></span><span id="riner::jrpc::JsonRpcUtil"></span><span class="target" id="classriner_1_1jrpc_1_1JsonRpcUtil"></span><em class="property">class </em><code class="sig-name descname">JsonRpcUtil</code> : <em class="property">private</em> riner::jrpc::<a class="reference internal" href="#_CPPv4N5riner4jrpc9JsonRpcIOE" title="riner::jrpc::JsonRpcIO">JsonRpcIO</a><a class="headerlink" href="#_CPPv4N5riner4jrpc11JsonRpcUtilE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="ioconnection">
<h2>IOConnection<a class="headerlink" href="#ioconnection" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner12IOConnectionE">
<span id="_CPPv3N5riner12IOConnectionE"></span><span id="_CPPv2N5riner12IOConnectionE"></span><span id="riner::IOConnection"></span><span class="target" id="classriner_1_1IOConnection"></span><em class="property">class </em><code class="sig-name descname">IOConnection</code><a class="headerlink" href="#_CPPv4N5riner12IOConnectionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Subclassed by <a class="reference internal" href="#structriner_1_1Connection"><span class="std std-ref">riner::Connection</span></a></p>
</dd></dl>

</div>
<div class="section" id="baseio">
<h2>BaseIO<a class="headerlink" href="#baseio" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner6BaseIOE">
<span id="_CPPv3N5riner6BaseIOE"></span><span id="_CPPv2N5riner6BaseIOE"></span><span id="riner::BaseIO"></span><span class="target" id="classriner_1_1BaseIO"></span><em class="property">class </em><code class="sig-name descname">BaseIO</code><a class="headerlink" href="#_CPPv4N5riner6BaseIOE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1BaseIO"><span class="std std-ref"><span class="pre">BaseIO</span></span></a></code> is the bottom most <a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref">IOTypeLayer</span></a> (that doesn’t actually derive from <a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref">IOTypeLayer</span></a>, as it has no successor). It implements the actual IO logic based on <code class="docutils literal notranslate"><span class="pre">std::string</span></code> lines (ending with a <p>‘` character) </p>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner6BaseIO6BaseIOEPKc6IOMode">
<span id="_CPPv3N5riner6BaseIO6BaseIOEPKc6IOMode"></span><span id="_CPPv2N5riner6BaseIO6BaseIOEPKc6IOMode"></span><span id="riner::BaseIO::BaseIO__cCP.IOMode"></span><span class="target" id="classriner_1_1BaseIO_1a8b3f7a7c63cf7c3347e14cfe8770b787"></span><code class="sig-name descname">BaseIO</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>customIOThreadName</em> = &quot;&quot;, IOMode <em>mode</em> = IOMode::Tcp<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner6BaseIO6BaseIOEPKc6IOMode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1BaseIO"><span class="std std-ref"><span class="pre">BaseIO</span></span></a></code>’s constructor starts the IO thread but does not yet enqueue any handlers on it. Connections initiated only in the <code class="docutils literal notranslate"><span class="pre">launchClient()</span></code> and <code class="docutils literal notranslate"><span class="pre">launchServer()</span></code> functions. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code>: unused </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">threadName</span></code>: pass the thread name that any IO thread created by this </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="cxnhandle">
<h2>CxnHandle<a class="headerlink" href="#cxnhandle" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9CxnHandleE">
<span id="_CPPv3N5riner9CxnHandleE"></span><span id="_CPPv2N5riner9CxnHandleE"></span><span id="riner::CxnHandle"></span><span class="target" id="classriner_1_1CxnHandle"></span><em class="property">class </em><code class="sig-name descname">CxnHandle</code><a class="headerlink" href="#_CPPv4N5riner9CxnHandleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#structriner_1_1Connection"><span class="std std-ref">Connection</span></a> Handle that is safe to be stored by the user and reused. If the corresponding connection no longer exists, the weak_ptr deals with that behavior safely. A connection is dropped when no operation is happening on it (e.g. no async read/writes are queued)</p>
<p>Implementation wise a <a class="reference internal" href="#classriner_1_1CxnHandle"><span class="std std-ref">CxnHandle</span></a> is just a glorified weak_ptr that can only be locked by <a class="reference internal" href="#classriner_1_1BaseIO"><span class="std std-ref">BaseIO</span></a> </p>
</dd></dl>

</div>
<div class="section" id="iotypelayer">
<h2>IOTypeLayer<a class="headerlink" href="#iotypelayer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I00EN5riner11IOTypeLayerE">
<span id="_CPPv3I00EN5riner11IOTypeLayerE"></span><span id="_CPPv2I00EN5riner11IOTypeLayerE"></span><span class="target" id="classriner_1_1IOTypeLayer"></span>template&lt;class <code class="sig-name descname">T</code>, class <code class="sig-name descname">LayerBelow</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">IOTypeLayer</code><a class="headerlink" href="#_CPPv4I00EN5riner11IOTypeLayerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> is used as a base class for network io abstractions that convert to/from certain types</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">example</span><span class="p">:</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">&lt;-&gt;</span> <span class="n">nl</span><span class="p">::</span><span class="n">json</span>              <span class="o">//</span><span class="n">one</span> <span class="n">IOTypeLayer</span>
                <span class="n">nl</span><span class="p">::</span><span class="n">json</span> <span class="o">&lt;-&gt;</span> <span class="n">JsonRpc</span>  <span class="o">//</span><span class="n">another</span> <span class="n">IOTypeLayer</span>
</pre></div>
</div>
</p>
<p>In this example, the incoming byte stream is first interpreted as a <code class="docutils literal notranslate"><span class="pre">std::string</span></code>, once that was successful, the next layer tries to parse the <code class="docutils literal notranslate"><span class="pre">std::string</span></code> as a <code class="docutils literal notranslate"><span class="pre">nl::json</span></code>. after that, the next layer tries to parse the <code class="docutils literal notranslate"><span class="pre">nl::json</span></code> as a <code class="docutils literal notranslate"><span class="pre">JsonRpc::Message</span></code>. The core functionality is only implemented based on <code class="docutils literal notranslate"><span class="pre">std::strings</span></code>, and the json and json-rpc layers only add 2 functions each for forward and backward conversions. Adding a new layer is as easy as providing 2 such conversion functions. The resulting <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> subclass still provides the same public interface as the implementation on the <code class="docutils literal notranslate"><span class="pre">std::string</span></code> level.</p>
<p>could be implemented as: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LineIO</span> <span class="p">{</span><span class="o">...</span><span class="p">};</span> <span class="o">//</span><span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">layer</span>
<span class="k">class</span> <span class="nc">JsonIO</span>       <span class="p">:</span> <span class="n">public</span> <span class="n">IOTypeLayer</span><span class="o">&lt;</span><span class="n">nl</span><span class="p">::</span><span class="n">json</span>        <span class="p">,</span> <span class="n">LineIO</span><span class="o">&gt;</span> <span class="p">{</span><span class="o">...</span><span class="p">};</span>
<span class="k">class</span> <span class="nc">JsonRpcIO</span>    <span class="p">:</span> <span class="n">public</span> <span class="n">IOTypeLayer</span><span class="o">&lt;</span><span class="n">JsonRpc</span><span class="p">::</span><span class="n">Message</span><span class="p">,</span> <span class="n">JsonIO</span><span class="o">&gt;</span> <span class="p">{</span><span class="o">...</span><span class="p">};</span>
</pre></div>
</div>
</p>
<p>in this example <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1LineIO"><span class="std std-ref"><span class="pre">LineIO</span></span></a></code> implements all the actual IO logic (which runs on <code class="docutils literal notranslate"><span class="pre">std::string</span></code>s). <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1JsonIO"><span class="std std-ref"><span class="pre">JsonIO</span></span></a></code> and <code class="docutils literal notranslate"><span class="pre">JsonRpcIO</span></code> only provide conversion functions while still being able to expose the same functionality as <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1LineIO"><span class="std std-ref"><span class="pre">LineIO</span></span></a></code>. In the end you only end up instantiating <code class="docutils literal notranslate"><span class="pre">JsonRpcIO</span></code>, which internally instantiates all the others in order to provide json-rpc related functionality.</p>
<p>this solution was chosen to make adding new generic features to all the IO type-abstractions less tedious. They now only have to be added to the bottom most layer and the <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> template.</p>
<p>If you want to implement a new layer, just subclass from the <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> you want to build on top of as shown above. Then implement a destructor that calls <code class="docutils literal notranslate"><span class="pre">stopIOThread()</span></code> to make sure no io thread handlers are executing while your class destroys its members. Finally override the following functions: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span>           <span class="n">convertIncoming</span><span class="p">(</span><span class="n">LayerBelowT</span><span class="p">)</span>
<span class="n">LayerBelowT</span> <span class="n">convertOutgoing</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
 in which you have to interpret the incoming messages from the layer below in terms of your layer’s type and translate them back upon sending. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv4IEN5riner11IOTypeLayerI1T10LayerBelowE12ModifierFuncE">
<span id="_CPPv3IEN5riner11IOTypeLayerI1T10LayerBelowE12ModifierFuncE"></span><span id="_CPPv2IEN5riner11IOTypeLayerI1T10LayerBelowE12ModifierFuncE"></span>template&lt;&gt;<br /><span class="target" id="classriner_1_1IOTypeLayer_1a4bfdcd3be74cc697d95aa4e1abec4e61"></span><em class="property">using </em><code class="sig-name descname">ModifierFunc</code> = std::function&lt;void<span class="sig-paren">(</span>T &amp;t<span class="sig-paren">)</span>&gt;<a class="headerlink" href="#_CPPv4IEN5riner11IOTypeLayerI1T10LayerBelowE12ModifierFuncE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Function type passed to <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a6d1b8a149eaf1df0fbd632363e573e96"><span class="std std-ref"><span class="pre">setIncomingModifier()</span></span></a></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a66755e93bb08a49f1f8f2839be6a4b11"><span class="std std-ref"><span class="pre">setOutgoingModifier()</span></span></a></code> </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer10layerBelowEv">
<span id="_CPPv3N5riner11IOTypeLayer10layerBelowEv"></span><span id="_CPPv2N5riner11IOTypeLayer10layerBelowEv"></span><span id="riner::IOTypeLayer::layerBelow"></span><span class="target" id="classriner_1_1IOTypeLayer_1a05f1dcb6c3b00181e07a08fa7615ca22"></span>LayerBelow &amp;<code class="sig-name descname">layerBelow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer10layerBelowEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>obtain the layer below, e.g. for setting modifier functions via <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a6d1b8a149eaf1df0fbd632363e573e96"><span class="std std-ref"><span class="pre">setIncomingModifier()</span></span></a></code> or <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a66755e93bb08a49f1f8f2839be6a4b11"><span class="std std-ref"><span class="pre">setOutgoingModifier()</span></span></a></code> for that specific layer’s type. Usually chained to obtain the layer you want (<code class="docutils literal notranslate"><span class="pre">io.layerBelow().</span><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a05f1dcb6c3b00181e07a08fa7615ca22"><span class="std std-ref"><span class="pre">layerBelow()</span></span></a><span class="pre">...</span></code>) <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the instance of <code class="docutils literal notranslate"><span class="pre">LayerBelow</span></code> that this layer builds upon </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer11IOTypeLayerEPKc6IOMode">
<span id="_CPPv3N5riner11IOTypeLayer11IOTypeLayerEPKc6IOMode"></span><span id="_CPPv2N5riner11IOTypeLayer11IOTypeLayerEPKc6IOMode"></span><span id="riner::IOTypeLayer::IOTypeLayer__cCP.IOMode"></span><span class="target" id="classriner_1_1IOTypeLayer_1a3627ad10b3a68341d76b5e1c5700209e"></span><code class="sig-name descname">IOTypeLayer</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>customIoThreadName</em> = &quot;&quot;, IOMode <em>mode</em> = IOMode::Tcp<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer11IOTypeLayerEPKc6IOMode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor of the <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref"><span class="pre">IOTypeLayer</span></span></a></code> does not establish any connection yet. Use <code class="docutils literal notranslate"><span class="pre">launchClient*()</span></code> or <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a19f932c9080f3b7097cbab5b57b6e807"><span class="std std-ref"><span class="pre">launchServer()</span></span></a></code> functions <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code>: not implemented yet </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer15convertIncomingE11LayerBelowT">
<span id="_CPPv3N5riner11IOTypeLayer15convertIncomingE11LayerBelowT"></span><span id="_CPPv2N5riner11IOTypeLayer15convertIncomingE11LayerBelowT"></span><span id="riner::IOTypeLayer::convertIncoming__LayerBelowT"></span><span class="target" id="classriner_1_1IOTypeLayer_1a1ce2fa8e74e4ce2e4d9eca3740d6bac4"></span><em class="property">virtual</em> T <code class="sig-name descname">convertIncoming</code><span class="sig-paren">(</span>LayerBelowT<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer15convertIncomingE11LayerBelowT" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>converts the incoming type from the layer below to the current layer’s type <code class="docutils literal notranslate"><span class="pre">T</span></code>. This function may throw an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1IOConversionError"><span class="std std-ref"><span class="pre">IOConversionError</span></span></a></code> if the conversion failed. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>successfully converted instance of <code class="docutils literal notranslate"><span class="pre">T</span></code> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer15convertOutgoingE1T">
<span id="_CPPv3N5riner11IOTypeLayer15convertOutgoingE1T"></span><span id="_CPPv2N5riner11IOTypeLayer15convertOutgoingE1T"></span><span id="riner::IOTypeLayer::convertOutgoing__T"></span><span class="target" id="classriner_1_1IOTypeLayer_1a5fe6a584f9f4bc9681e600a5aa823e62"></span><em class="property">virtual</em> LayerBelowT <code class="sig-name descname">convertOutgoing</code><span class="sig-paren">(</span>T<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer15convertOutgoingE1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>converts the outgoing type from this layer’s <code class="docutils literal notranslate"><span class="pre">T</span></code> to the type of the layer below. This function may throw an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1IOConversionError"><span class="std std-ref"><span class="pre">IOConversionError</span></span></a></code> if the conversion failed. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>successfully converted instance of <code class="docutils literal notranslate"><span class="pre">LayerBelowT</span></code> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer19setIncomingModifierERR12ModifierFunc">
<span id="_CPPv3N5riner11IOTypeLayer19setIncomingModifierERR12ModifierFunc"></span><span id="_CPPv2N5riner11IOTypeLayer19setIncomingModifierERR12ModifierFunc"></span><span id="riner::IOTypeLayer::setIncomingModifier__ModifierFuncRR"></span><span class="target" id="classriner_1_1IOTypeLayer_1a6d1b8a149eaf1df0fbd632363e573e96"></span>void <code class="sig-name descname">setIncomingModifier</code><span class="sig-paren">(</span>ModifierFunc &amp;&amp;<em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer19setIncomingModifierERR12ModifierFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>provide a <code class="docutils literal notranslate"><span class="pre">ModifierFunc</span></code> which can define custom modifications that will be applied to any incoming <code class="docutils literal notranslate"><span class="pre">T</span></code> object before it is exposed in any other way. This is useful e.g. if a specific pool protocol is implemented that has some minor quirks on the way it expects Json Rpcs to behave. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">func</span></code>: function that lets the user modify every incoming <code class="docutils literal notranslate"><span class="pre">T</span></code> before it gets exposed otherwise </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer19setOutgoingModifierERR12ModifierFunc">
<span id="_CPPv3N5riner11IOTypeLayer19setOutgoingModifierERR12ModifierFunc"></span><span id="_CPPv2N5riner11IOTypeLayer19setOutgoingModifierERR12ModifierFunc"></span><span id="riner::IOTypeLayer::setOutgoingModifier__ModifierFuncRR"></span><span class="target" id="classriner_1_1IOTypeLayer_1a66755e93bb08a49f1f8f2839be6a4b11"></span>void <code class="sig-name descname">setOutgoingModifier</code><span class="sig-paren">(</span>ModifierFunc &amp;&amp;<em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer19setOutgoingModifierERR12ModifierFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>provide a <code class="docutils literal notranslate"><span class="pre">ModifierFunc</span></code> that can define custom modifications that will be applied to any outgoing <code class="docutils literal notranslate"><span class="pre">T</span></code> object before it is converted to a <code class="docutils literal notranslate"><span class="pre">LayerBelowT</span></code>. This is useful e.g. if a specific pool protocol is implemented that has some minor quirks on the way it expects Json Rpcs to behave. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">func</span></code>: function that lets the user modify every outgoing <code class="docutils literal notranslate"><span class="pre">T</span></code> before it is sent </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer9enableSslERK7SslDesc">
<span id="_CPPv3N5riner11IOTypeLayer9enableSslERK7SslDesc"></span><span id="_CPPv2N5riner11IOTypeLayer9enableSslERK7SslDesc"></span><span id="riner::IOTypeLayer::enableSsl__SslDescCR"></span><span class="target" id="classriner_1_1IOTypeLayer_1a5babf8b6ec599a6b381662352e365dfc"></span>void <code class="sig-name descname">enableSsl</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner7SslDescE" title="riner::SslDesc">SslDesc</a> &amp;<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer9enableSslERK7SslDesc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use this function to enable ssl (configurable via <code class="docutils literal notranslate"><span class="pre">desc</span></code>) for the connections that will be opened by this IO object. This function must be called before any launch* functions. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer9readAsyncE9CxnHandle">
<span id="_CPPv3N5riner11IOTypeLayer9readAsyncE9CxnHandle"></span><span id="_CPPv2N5riner11IOTypeLayer9readAsyncE9CxnHandle"></span><span id="riner::IOTypeLayer::readAsync__CxnHandle"></span><span class="target" id="classriner_1_1IOTypeLayer_1af6ca014e4953243d7171e5125c679e0f"></span>void <code class="sig-name descname">readAsync</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5riner9CxnHandleE" title="riner::CxnHandle">CxnHandle</a> <em>cxn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer9readAsyncE9CxnHandle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enqueues an async read operation on the provided <code class="docutils literal notranslate"><span class="pre">cxn</span></code> and keeps that <code class="docutils literal notranslate"><span class="pre">cxn</span></code> alive (if it hasn’t disconnected yet). Once a read was queued and bytes were received that successfully went through the chain of <code class="docutils literal notranslate"><span class="pre">IOTypeLayers</span></code>, the optional <code class="docutils literal notranslate"><span class="pre">OnReceiveValueFunc</span></code> provided in <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a2bc1cf93d19b46365194d59fb16ef30b"><span class="std std-ref"><span class="pre">setOnReceive()</span></span></a></code> gets called with the resulting <code class="docutils literal notranslate"><span class="pre">T</span></code> instance. Otherwise (if no func was provided) the behavior is identical, but the default <code class="docutils literal notranslate"><span class="pre">OnReceiveValueFunc</span></code> (=noop) gets called. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cxn</span></code>: the connection handle to queue a read operation on </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer12setOnReceiveERR18OnReceiveValueFunc">
<span id="_CPPv3N5riner11IOTypeLayer12setOnReceiveERR18OnReceiveValueFunc"></span><span id="_CPPv2N5riner11IOTypeLayer12setOnReceiveERR18OnReceiveValueFunc"></span><span id="riner::IOTypeLayer::setOnReceive__OnReceiveValueFuncRR"></span><span class="target" id="classriner_1_1IOTypeLayer_1a2bc1cf93d19b46365194d59fb16ef30b"></span>void <code class="sig-name descname">setOnReceive</code><span class="sig-paren">(</span>OnReceiveValueFunc &amp;&amp;<em>onRecv</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer12setOnReceiveERR18OnReceiveValueFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Provide a function that gets called whenever an incoming message was successfully converted to a <code class="docutils literal notranslate"><span class="pre">T</span></code> (e.g. if no exceptions were thrown) and also passes an <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1CxnHandle"><span class="std std-ref"><span class="pre">CxnHandle</span></span></a></code> that can be used within that callback to send responses/queue reads <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">onRecv</span></code>: the function that is called upon receiving a <code class="docutils literal notranslate"><span class="pre">T</span></code> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer10writeAsyncE9CxnHandle1T">
<span id="_CPPv3N5riner11IOTypeLayer10writeAsyncE9CxnHandle1T"></span><span id="_CPPv2N5riner11IOTypeLayer10writeAsyncE9CxnHandle1T"></span><span id="riner::IOTypeLayer::writeAsync__CxnHandle.T"></span><span class="target" id="classriner_1_1IOTypeLayer_1a728f321e7e792f3ebd90f40b2105c2c7"></span>void <code class="sig-name descname">writeAsync</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5riner9CxnHandleE" title="riner::CxnHandle">CxnHandle</a> <em>cxn</em>, T <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer10writeAsyncE9CxnHandle1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enqueues an async write operation on the provided <code class="docutils literal notranslate"><span class="pre">cxn</span></code> and keeps that <code class="docutils literal notranslate"><span class="pre">cxn</span></code> alive (if it hasn’t disconnected yet). The t object will get converted down to the base layer on the calling thread, then the actual async write is queued. For more details see boost::asio’s <code class="docutils literal notranslate"><span class="pre">async_write</span></code>. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cxn</span></code>: the connection handle to queue a write operation on </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: the object that gets first converted to the bottom most layer and then async-sent over the <code class="docutils literal notranslate"><span class="pre">cxn</span></code> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN5riner11IOTypeLayer9postAsyncEvRR4Func">
<span id="_CPPv3I0EN5riner11IOTypeLayer9postAsyncERR4Func"></span><span id="_CPPv2I0EN5riner11IOTypeLayer9postAsyncERR4Func"></span><span class="target" id="classriner_1_1IOTypeLayer_1a9f399059b881be2962ceaa82da90d4dd"></span>template&lt;class <code class="sig-name descname">Func</code>&gt;<br />void <code class="sig-name descname">postAsync</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN5riner11IOTypeLayer9postAsyncEvRR4Func" title="riner::IOTypeLayer::postAsync::Func">Func</a> &amp;&amp;<em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5riner11IOTypeLayer9postAsyncEvRR4Func" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enqueue an arbitrary function to run on the IO thread. For more details see boost::asio’s <code class="docutils literal notranslate"><span class="pre">asio::post</span></code>. <dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Func</span></code>: functor with a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">operator()</span></code> that takes no arguments </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">func</span></code>: the function which is going to be executed on the io thread. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer15retryAsyncEveryE12millisecondsRRNSt8functionIFbvEEENSt8functionIFvvEEE">
<span id="_CPPv3N5riner11IOTypeLayer15retryAsyncEveryE12millisecondsRRNSt8functionIFbvEEENSt8functionIFvvEEE"></span><span id="_CPPv2N5riner11IOTypeLayer15retryAsyncEveryE12millisecondsRRNSt8functionIFbvEEENSt8functionIFvvEEE"></span><span class="target" id="classriner_1_1IOTypeLayer_1a4b69b99077f503793edc8634e8b220c7"></span>void <code class="sig-name descname">retryAsyncEvery</code><span class="sig-paren">(</span>milliseconds <em>retryInterval</em>, std::function&lt;bool<span class="sig-paren">(</span><span class="sig-paren">)</span>&gt; &amp;&amp;<em>pred</em>std::function&lt;void<span class="sig-paren">(</span><span class="sig-paren">)</span>&gt; <em>onCancelled</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer15retryAsyncEveryE12millisecondsRRNSt8functionIFbvEEENSt8functionIFvvEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call an arbitrary predicate function every <code class="docutils literal notranslate"><span class="pre">retryInterval</span></code> milliseconds until it succeeds (returns <code class="docutils literal notranslate"><span class="pre">true</span></code>) for the first time. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">retryInterval</span></code>: the time duration to wait between the individual tries </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pred</span></code>: the function that should be called repeatedly until it returns <code class="docutils literal notranslate"><span class="pre">true</span></code> for the first time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onCancelled</span></code>: the function that should be called if the retrires had to be cancelled (e.g. if the <a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref">IOTypeLayer</span></a> got destroyed, or all handlers got aborted due to disconnectAll call). This function is guaranteed to be called after the ioThread is no longer executing (=joined). The function is called from within a user’s thread that interacts with this io object (e.g. via its dtor). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer12launchClientENSt6stringE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc">
<span id="_CPPv3N5riner11IOTypeLayer12launchClientENSt6stringE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc"></span><span id="_CPPv2N5riner11IOTypeLayer12launchClientENSt6stringE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc"></span><span id="riner::IOTypeLayer::launchClient__ss.uint16_t.IOOnConnectedFunc.IOOnDisconnectedFunc"></span><span class="target" id="classriner_1_1IOTypeLayer_1a2ddd3effdd8f3efabd57a36f9749b9b6"></span>void <code class="sig-name descname">launchClient</code><span class="sig-paren">(</span>std::string <em>host</em>, uint16_t <em>port</em>, IOOnConnectedFunc <em>onCxn</em> = ioOnConnectedNoop, IOOnDisconnectedFunc <em>onDc</em> = ioOnDisconnectedNoop<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer12launchClientENSt6stringE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a2ddd3effdd8f3efabd57a36f9749b9b6"><span class="std std-ref"><span class="pre">launchClient()</span></span></a></code> opens a single connection to the given host, port. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">host</span></code>: host name or ip e.g. “localhost” or “127.0.0.1” to connect to </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port</span></code>: port to connect to </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onCxn</span></code>: function that gets called on the io thread when a successful connection was established. A <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1CxnHandle"><span class="std std-ref"><span class="pre">CxnHandle</span></span></a></code> is provided as a parameter to enqueue further operations on that connection. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onDc</span></code>: function that gets called (not necessarily on the io thread!) when the connection was either closed on the other side, lost, closed on this side, or unable to be established in the first place by no longer enqueueing any async read/write operations on the <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1CxnHandle"><span class="std std-ref"><span class="pre">CxnHandle</span></span></a></code> after it was successfully connected. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer25launchClientAutoReconnectENSt6stringE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc">
<span id="_CPPv3N5riner11IOTypeLayer25launchClientAutoReconnectENSt6stringE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc"></span><span id="_CPPv2N5riner11IOTypeLayer25launchClientAutoReconnectENSt6stringE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc"></span><span id="riner::IOTypeLayer::launchClientAutoReconnect__ss.uint16_t.IOOnConnectedFunc.IOOnDisconnectedFunc"></span><span class="target" id="classriner_1_1IOTypeLayer_1a7bcb799079dfbf8a1235f5557dd38b64"></span>void <code class="sig-name descname">launchClientAutoReconnect</code><span class="sig-paren">(</span>std::string <em>host</em>, uint16_t <em>port</em>, IOOnConnectedFunc <em>onCxn</em> = ioOnConnectedNoop, IOOnDisconnectedFunc <em>onDc</em> = ioOnDisconnectedNoop<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer25launchClientAutoReconnectENSt6stringE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a2ddd3effdd8f3efabd57a36f9749b9b6"><span class="std std-ref"><span class="pre">launchClient()</span></span></a></code>, but it tries to reconnect whenever a connection was lost. The <code class="docutils literal notranslate"><span class="pre">onDc</span></code> and later <code class="docutils literal notranslate"><span class="pre">onCxn</span></code> callbacks also get called whenever that happens. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">onCxn</span></code>: function that gets called on the io thread whenever a successful connection was established. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onDc</span></code>: function that gets called (not necessarily on the io thread!) whenever a connection was closed from the other side, lost, or closed on this side. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer12launchServerE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc">
<span id="_CPPv3N5riner11IOTypeLayer12launchServerE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc"></span><span id="_CPPv2N5riner11IOTypeLayer12launchServerE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc"></span><span id="riner::IOTypeLayer::launchServer__uint16_t.IOOnConnectedFunc.IOOnDisconnectedFunc"></span><span class="target" id="classriner_1_1IOTypeLayer_1a19f932c9080f3b7097cbab5b57b6e807"></span>bool <code class="sig-name descname">launchServer</code><span class="sig-paren">(</span>uint16_t <em>port</em>, IOOnConnectedFunc <em>onCxn</em> = ioOnConnectedNoop, IOOnDisconnectedFunc <em>onDc</em> = ioOnDisconnectedNoop<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer12launchServerE8uint16_t17IOOnConnectedFunc20IOOnDisconnectedFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1IOTypeLayer_1a19f932c9080f3b7097cbab5b57b6e807"><span class="std std-ref"><span class="pre">launchServer()</span></span></a></code> listens on the provided port for incoming connections. For every connection, a <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1CxnHandle"><span class="std std-ref"><span class="pre">CxnHandle</span></span></a></code> is created and the <code class="docutils literal notranslate"><span class="pre">onCxn</span></code> callback is called with it. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">port</span></code>: the port to listen on for connections </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onCxn</span></code>: the function that is called on the IO thread on every successfully established connection </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onDc</span></code>: function that gets called (not necessarily on the io thread!) whenever a connection was closed from the other side, lost, or closed on this side. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer10isIoThreadEv">
<span id="_CPPv3N5riner11IOTypeLayer10isIoThreadEv"></span><span id="_CPPv2N5riner11IOTypeLayer10isIoThreadEv"></span><span id="riner::IOTypeLayer::isIoThread"></span><span class="target" id="classriner_1_1IOTypeLayer_1abfb4e521e1c247f9014878f120ff997d"></span>bool <code class="sig-name descname">isIoThread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer10isIoThreadEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check whether the calling thread is the io thread. this function can be called from any thread <dl class="simple">
<dt><strong>Return</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the calling thread is the io thread owned by this object, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer15processIncomingE11LayerBelowT">
<span id="_CPPv3N5riner11IOTypeLayer15processIncomingE11LayerBelowT"></span><span id="_CPPv2N5riner11IOTypeLayer15processIncomingE11LayerBelowT"></span><span id="riner::IOTypeLayer::processIncoming__LayerBelowT"></span><span class="target" id="classriner_1_1IOTypeLayer_1af82c40be8625331d3a712f029f318459"></span>T <code class="sig-name descname">processIncoming</code><span class="sig-paren">(</span>LayerBelowT <em>lbt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer15processIncomingE11LayerBelowT" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>apply all necessary changes to the incoming data so that it can be processed as a <code class="docutils literal notranslate"><span class="pre">T</span></code> <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>data converted to instance of <code class="docutils literal notranslate"><span class="pre">T</span></code> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lbt</span></code>: received data in the type of the layer below </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11IOTypeLayer15processOutgoingE1T">
<span id="_CPPv3N5riner11IOTypeLayer15processOutgoingE1T"></span><span id="_CPPv2N5riner11IOTypeLayer15processOutgoingE1T"></span><span id="riner::IOTypeLayer::processOutgoing__T"></span><span class="target" id="classriner_1_1IOTypeLayer_1a7a9f160dc744d88e031642c65498e7b2"></span>LayerBelowT <code class="sig-name descname">processOutgoing</code><span class="sig-paren">(</span>T <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11IOTypeLayer15processOutgoingE1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>apply all necessary changes to the incoming <code class="docutils literal notranslate"><span class="pre">T</span></code> so that it can be interpreted by the layer below <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>t in the type of the layer below </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: that is about to be sent </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="method">
<h2>Method<a class="headerlink" href="#method" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4jrpc6MethodE">
<span id="_CPPv3N5riner4jrpc6MethodE"></span><span id="_CPPv2N5riner4jrpc6MethodE"></span><span id="riner::jrpc::Method"></span><span class="target" id="classriner_1_1jrpc_1_1Method"></span><em class="property">class </em><code class="sig-name descname">Method</code><a class="headerlink" href="#_CPPv4N5riner4jrpc6MethodE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="requestbuilder">
<h2>RequestBuilder<a class="headerlink" href="#requestbuilder" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4jrpc14RequestBuilderE">
<span id="_CPPv3N5riner4jrpc14RequestBuilderE"></span><span id="_CPPv2N5riner4jrpc14RequestBuilderE"></span><span id="riner::jrpc::RequestBuilder"></span><span class="target" id="classriner_1_1jrpc_1_1RequestBuilder"></span><em class="property">class </em><code class="sig-name descname">RequestBuilder</code><a class="headerlink" href="#_CPPv4N5riner4jrpc14RequestBuilderE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Builder pattern convenience class for creating a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Request"><span class="std std-ref"><span class="pre">jrpc::Request</span></span></a></code> </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner4jrpc14RequestBuilder2idEN2nl4jsonE">
<span id="_CPPv3N5riner4jrpc14RequestBuilder2idEN2nl4jsonE"></span><span id="_CPPv2N5riner4jrpc14RequestBuilder2idEN2nl4jsonE"></span><span id="riner::jrpc::RequestBuilder::id__nl::json"></span><span class="target" id="classriner_1_1jrpc_1_1RequestBuilder_1a40ab9d5c5781e8b2ac5df777396aff4f"></span><a class="reference internal" href="#_CPPv4N5riner4jrpc14RequestBuilderE" title="riner::jrpc::RequestBuilder">RequestBuilder</a> &amp;<code class="sig-name descname">id</code><span class="sig-paren">(</span>nl::json <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc14RequestBuilder2idEN2nl4jsonE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message_1aec7563c459d8089c55b23846511b7b10"><span class="std std-ref"><span class="pre">Message::id</span></span></a></code> <dl class="simple">
<dt><strong>Return</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">*this</span></code> (builder pattern) </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4jrpc14RequestBuilder6methodE6String">
<span id="_CPPv3N5riner4jrpc14RequestBuilder6methodE6String"></span><span id="_CPPv2N5riner4jrpc14RequestBuilder6methodE6String"></span><span id="riner::jrpc::RequestBuilder::method__String"></span><span class="target" id="classriner_1_1jrpc_1_1RequestBuilder_1a4c58a95a78053cd19c24cc08ace1afaa"></span><a class="reference internal" href="#_CPPv4N5riner4jrpc14RequestBuilderE" title="riner::jrpc::RequestBuilder">RequestBuilder</a> &amp;<code class="sig-name descname">method</code><span class="sig-paren">(</span>String <em>methodName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc14RequestBuilder6methodE6String" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set <code class="docutils literal notranslate"><span class="pre">Request::method</span></code> <dl class="simple">
<dt><strong>Return</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">*this</span></code> (builder pattern) </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4jrpc14RequestBuilder5paramEPKcN2nl4jsonE">
<span id="_CPPv3N5riner4jrpc14RequestBuilder5paramEPKcN2nl4jsonE"></span><span id="_CPPv2N5riner4jrpc14RequestBuilder5paramEPKcN2nl4jsonE"></span><span id="riner::jrpc::RequestBuilder::param__cCP.nl::json"></span><span class="target" id="classriner_1_1jrpc_1_1RequestBuilder_1ac8b139f0a7ed780b60483a3b636d6dc8"></span><a class="reference internal" href="#_CPPv4N5riner4jrpc14RequestBuilderE" title="riner::jrpc::RequestBuilder">RequestBuilder</a> &amp;<code class="sig-name descname">param</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>key</em>, nl::json <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc14RequestBuilder5paramEPKcN2nl4jsonE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a named param. It is not valid to add a named param if unnamed params were added before to the same <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1jrpc_1_1RequestBuilder"><span class="std std-ref"><span class="pre">RequestBuilder</span></span></a></code> <dl class="simple">
<dt><strong>Return</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">*this</span></code> (builder pattern) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code>: name of the param </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">val</span></code>: value of the param </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4jrpc14RequestBuilder5paramEN2nl4jsonE">
<span id="_CPPv3N5riner4jrpc14RequestBuilder5paramEN2nl4jsonE"></span><span id="_CPPv2N5riner4jrpc14RequestBuilder5paramEN2nl4jsonE"></span><span id="riner::jrpc::RequestBuilder::param__nl::json"></span><span class="target" id="classriner_1_1jrpc_1_1RequestBuilder_1aa2950230c4361a46cccfac887c9f8064"></span><a class="reference internal" href="#_CPPv4N5riner4jrpc14RequestBuilderE" title="riner::jrpc::RequestBuilder">RequestBuilder</a> &amp;<code class="sig-name descname">param</code><span class="sig-paren">(</span>nl::json <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc14RequestBuilder5paramEN2nl4jsonE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add an unnamed param. It is not valid to add an unnamed param if named params were added before to the same <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1jrpc_1_1RequestBuilder"><span class="std std-ref"><span class="pre">RequestBuilder</span></span></a></code> <dl class="simple">
<dt><strong>Return</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">*this</span></code> (builder pattern) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">val</span></code>: value of the param </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4jrpc14RequestBuilder4doneEv">
<span id="_CPPv3N5riner4jrpc14RequestBuilder4doneEv"></span><span id="_CPPv2N5riner4jrpc14RequestBuilder4doneEv"></span><span id="riner::jrpc::RequestBuilder::done"></span><span class="target" id="classriner_1_1jrpc_1_1RequestBuilder_1aa88adc75a46232baa8f3d96eca481157"></span><a class="reference internal" href="#_CPPv4N5riner4jrpc7MessageE" title="riner::jrpc::Message">Message</a> <code class="sig-name descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc14RequestBuilder4doneEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call this function to end the building process and <code class="docutils literal notranslate"><span class="pre">std::move</span></code> the internal <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">jrpc::Message</span></span></a></code> out. Afterwards, this object is in a <a class="reference external" href="https://en.cppreference.com/w/cpp/utility/move">‘valid but unspecified state’</a>. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="socket">
<h2>Socket<a class="headerlink" href="#socket" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner6SocketE">
<span id="_CPPv3N5riner6SocketE"></span><span id="_CPPv2N5riner6SocketE"></span><span id="riner::Socket"></span><span class="target" id="classriner_1_1Socket"></span><em class="property">class </em><code class="sig-name descname">Socket</code><a class="headerlink" href="#_CPPv4N5riner6SocketE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv4N5riner6Socket13HandshakeFuncE">
<span id="_CPPv3N5riner6Socket13HandshakeFuncE"></span><span id="_CPPv2N5riner6Socket13HandshakeFuncE"></span><span class="target" id="classriner_1_1Socket_1a19ac0de33a47d84d0e8896e8d8fe4273"></span><em class="property">using </em><code class="sig-name descname">HandshakeFunc</code> = std::function&lt;void<span class="sig-paren">(</span><em class="property">const</em> asio::error_code&amp;<span class="sig-paren">)</span>&gt;<a class="headerlink" href="#_CPPv4N5riner6Socket13HandshakeFuncE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>if initialized as a ssl socket, performs ssl handshake, otherwise nothing. use handler to continue </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner6Socket9tcpStreamEv">
<span id="_CPPv3N5riner6Socket9tcpStreamEv"></span><span id="_CPPv2N5riner6Socket9tcpStreamEv"></span><span id="riner::Socket::tcpStream"></span><span class="target" id="classriner_1_1Socket_1ac54607e1ac9fd82f5b6a9e64f26e4cf6"></span>asio::basic_stream_socket&lt;tcp&gt; &amp;<code class="sig-name descname">tcpStream</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner6Socket9tcpStreamEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a reference to the underlying TCP socket. NOTE: Boost provides no common base class for TCP and SSL sockets. Therefore the async_* member functions provide this abstraction <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TCP stream used by TCP or SSL connection </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="algodummy">
<h2>AlgoDummy<a class="headerlink" href="#algodummy" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9AlgoDummyE">
<span id="_CPPv3N5riner9AlgoDummyE"></span><span id="_CPPv2N5riner9AlgoDummyE"></span><span id="riner::AlgoDummy"></span><span class="target" id="classriner_1_1AlgoDummy"></span><em class="property">class </em><code class="sig-name descname">AlgoDummy</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner9AlgorithmE" title="riner::Algorithm">Algorithm</a><a class="headerlink" href="#_CPPv4N5riner9AlgoDummyE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="algorithm">
<h2>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9AlgorithmE">
<span id="_CPPv3N5riner9AlgorithmE"></span><span id="_CPPv2N5riner9AlgorithmE"></span><span id="riner::Algorithm"></span><span class="target" id="classriner_1_1Algorithm"></span><em class="property">class </em><code class="sig-name descname">Algorithm</code><a class="headerlink" href="#_CPPv4N5riner9AlgorithmE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>common base class for all AlgoImpls when subclassing Algorithm, do not forget to add your algorithm to the registry in ‘Registry.cpp’ </p>
<p>Subclassed by <a class="reference internal" href="#classriner_1_1AlgoCuckatoo31Cl"><span class="std std-ref">riner::AlgoCuckatoo31Cl</span></a>, <a class="reference internal" href="#classriner_1_1AlgoDummy"><span class="std std-ref">riner::AlgoDummy</span></a>, <a class="reference internal" href="#classriner_1_1AlgoEthashCL"><span class="std std-ref">riner::AlgoEthashCL</span></a></p>
</dd></dl>

</div>
<div class="section" id="taskexecutorpool">
<h2>TaskExecutorPool<a class="headerlink" href="#taskexecutorpool" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner16TaskExecutorPoolE">
<span id="_CPPv3N5riner16TaskExecutorPoolE"></span><span id="_CPPv2N5riner16TaskExecutorPoolE"></span><span id="riner::TaskExecutorPool"></span><span class="target" id="classriner_1_1TaskExecutorPool"></span><em class="property">class </em><code class="sig-name descname">TaskExecutorPool</code><a class="headerlink" href="#_CPPv4N5riner16TaskExecutorPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Launches some worker threads and provides functionality for pushing tasks to the pool, which are then executed by the worker threads. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner16TaskExecutorPool14setThreadCountE6size_t">
<span id="_CPPv3N5riner16TaskExecutorPool14setThreadCountE6size_t"></span><span id="_CPPv2N5riner16TaskExecutorPool14setThreadCountE6size_t"></span><span id="riner::TaskExecutorPool::setThreadCount__s"></span><span class="target" id="classriner_1_1TaskExecutorPool_1afbf17608d2ca81a3a1bd5eeeeda0fbe3"></span>void <code class="sig-name descname">setThreadCount</code><span class="sig-paren">(</span>size_t <em>numThreads</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner16TaskExecutorPool14setThreadCountE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>change the worker thread count after the object was already initialized (setting the number of threads can instead also be done right in the constructor </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0_NSt11enable_if_tIXntNSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F">
<span id="_CPPv3I0_NSt11enable_if_tIXntNSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEEiEEEN5riner16TaskExecutorPool7addTaskERR1F"></span><span id="_CPPv2I0_NSt11enable_if_tIX!std::is_same<std::result_of_t<F&&()>, void>::valueEiEEEN5riner16TaskExecutorPool7addTaskERR1F"></span><span class="target" id="classriner_1_1TaskExecutorPool_1a0b4c7ad5c5fd80fe9ec30857bb6769dd"></span>template&lt;typename <code class="sig-name descname">F</code>, std::enable_if_t&lt;!std::is_same&lt;std::result_of_t&lt;<a class="reference internal" href="#_CPPv4I0_NSt11enable_if_tIXntNSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F" title="riner::TaskExecutorPool::addTask::F">F</a>&amp;&amp;<span class="sig-paren">(</span><span class="sig-paren">)</span>&gt;, void&gt;::value, int&gt; <code class="sig-name descname">N</code> = 0&gt;<br />std::future&lt;std::result_of_t&lt;<a class="reference internal" href="#_CPPv4I0_NSt11enable_if_tIXntNSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F" title="riner::TaskExecutorPool::addTask::F">F</a>&amp;&amp;<span class="sig-paren">(</span><span class="sig-paren">)</span>&gt;&gt; <code class="sig-name descname">addTask</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0_NSt11enable_if_tIXntNSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F" title="riner::TaskExecutorPool::addTask::F">F</a> &amp;&amp;<em>fct</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0_NSt11enable_if_tIXntNSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>addTask that returns a value. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a std::future&lt;X&gt; where X is fct’s return type. Can be used to query if the task is done. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fct</span></code>: task that will be executed by the worker threads as soon as possible </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0_NSt11enable_if_tINSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F">
<span id="_CPPv3I0_NSt11enable_if_tINSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEiEEEN5riner16TaskExecutorPool7addTaskERR1F"></span><span id="_CPPv2I0_NSt11enable_if_tINSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEiEEEN5riner16TaskExecutorPool7addTaskERR1F"></span><span class="target" id="classriner_1_1TaskExecutorPool_1a0b4c7ad5c5fd80fe9ec30857bb6769dd"></span>template&lt;typename <code class="sig-name descname">F</code>, std::enable_if_t&lt;std::is_same&lt;std::result_of_t&lt;<a class="reference internal" href="#_CPPv4I0_NSt11enable_if_tINSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F" title="riner::TaskExecutorPool::addTask::F">F</a>&amp;&amp;<span class="sig-paren">(</span><span class="sig-paren">)</span>&gt;, void&gt;::value, int&gt; <code class="sig-name descname">N</code> = 0&gt;<br />std::future&lt;std::result_of_t&lt;<a class="reference internal" href="#_CPPv4I0_NSt11enable_if_tINSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F" title="riner::TaskExecutorPool::addTask::F">F</a>&amp;&amp;<span class="sig-paren">(</span><span class="sig-paren">)</span>&gt;&gt; <code class="sig-name descname">addTask</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0_NSt11enable_if_tINSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F" title="riner::TaskExecutorPool::addTask::F">F</a> &amp;&amp;<em>fct</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0_NSt11enable_if_tINSt7is_sameINSt11result_of_tIFRR1FvEEEvE5valueEiEEEN5riner16TaskExecutorPool7addTaskENSt6futureINSt11result_of_tIFRR1FvEEEEERR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>specialization of addTask for functions that return void. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a std::future&lt;void&gt; for querying if the task is done. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fct</span></code>: task that will be executed by the worker threads as soon as possible </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner16TaskExecutorPool16TaskExecutorPoolEv">
<span id="_CPPv3N5riner16TaskExecutorPool16TaskExecutorPoolEv"></span><span id="_CPPv2N5riner16TaskExecutorPool16TaskExecutorPoolEv"></span><span id="riner::TaskExecutorPool::TaskExecutorPool"></span><span class="target" id="classriner_1_1TaskExecutorPool_1abb21cd3b92779a9973bdb65b95ef8eac"></span><code class="sig-name descname">TaskExecutorPool</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner16TaskExecutorPool16TaskExecutorPoolEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize the pool with the amount of hardware threads your machine has minus 1 workers. If theres only one hardware thread, this constructor will still create 1 thread </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner16TaskExecutorPool16TaskExecutorPoolE6size_t">
<span id="_CPPv3N5riner16TaskExecutorPool16TaskExecutorPoolE6size_t"></span><span id="_CPPv2N5riner16TaskExecutorPool16TaskExecutorPoolE6size_t"></span><span id="riner::TaskExecutorPool::TaskExecutorPool__s"></span><span class="target" id="classriner_1_1TaskExecutorPool_1a5918486f08eaa47f3d0a9bf80392d27d"></span><code class="sig-name descname">TaskExecutorPool</code><span class="sig-paren">(</span>size_t <em>numThreads</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner16TaskExecutorPool16TaskExecutorPoolE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize the pool with a specific number of worker threads. Will at minimum initialize one worker, even if 0 is passed. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner16TaskExecutorPoolD0Ev">
<span id="_CPPv3N5riner16TaskExecutorPoolD0Ev"></span><span id="_CPPv2N5riner16TaskExecutorPoolD0Ev"></span><span id="riner::TaskExecutorPool::~TaskExecutorPool"></span><span class="target" id="classriner_1_1TaskExecutorPool_1a7c36e35993881a5b66fdce21ce1a0ce6"></span><code class="sig-name descname">~TaskExecutorPool</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner16TaskExecutorPoolD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>joins all threads. Does not wait until all tasks were finished (may leave tasks unfinished) </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="algocuckatoo31cl">
<h2>AlgoCuckatoo31Cl<a class="headerlink" href="#algocuckatoo31cl" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner16AlgoCuckatoo31ClE">
<span id="_CPPv3N5riner16AlgoCuckatoo31ClE"></span><span id="_CPPv2N5riner16AlgoCuckatoo31ClE"></span><span id="riner::AlgoCuckatoo31Cl"></span><span class="target" id="classriner_1_1AlgoCuckatoo31Cl"></span><em class="property">class </em><code class="sig-name descname">AlgoCuckatoo31Cl</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner9AlgorithmE" title="riner::Algorithm">Algorithm</a><a class="headerlink" href="#_CPPv4N5riner16AlgoCuckatoo31ClE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="id1">
<h2>Algorithm<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9AlgorithmE">
<span id="_CPPv3N5riner9AlgorithmE"></span><span id="_CPPv2N5riner9AlgorithmE"></span><span class="target" id="classriner_1_1Algorithm"></span><em class="property">class </em><code class="sig-name descname">Algorithm</code><br /></dt>
<dd><p>common base class for all AlgoImpls when subclassing Algorithm, do not forget to add your algorithm to the registry in ‘Registry.cpp’ </p>
<p>Subclassed by <a class="reference internal" href="#classriner_1_1AlgoCuckatoo31Cl"><span class="std std-ref">riner::AlgoCuckatoo31Cl</span></a>, <a class="reference internal" href="#classriner_1_1AlgoDummy"><span class="std std-ref">riner::AlgoDummy</span></a>, <a class="reference internal" href="#classriner_1_1AlgoEthashCL"><span class="std std-ref">riner::AlgoEthashCL</span></a></p>
</dd></dl>

</div>
<div class="section" id="dagfile">
<h2>DagFile<a class="headerlink" href="#dagfile" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner7DagFileE">
<span id="_CPPv3N5riner7DagFileE"></span><span id="_CPPv2N5riner7DagFileE"></span><span id="riner::DagFile"></span><span class="target" id="classriner_1_1DagFile"></span><em class="property">class </em><code class="sig-name descname">DagFile</code><a class="headerlink" href="#_CPPv4N5riner7DagFileE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Utility for generating the ethash <a class="reference internal" href="#classriner_1_1DagFile"><span class="std std-ref">DagFile</span></a> on the gpu via opencl see the generate method. </p>
</dd></dl>

</div>
<div class="section" id="dagcachecontainer">
<h2>DagCacheContainer<a class="headerlink" href="#dagcachecontainer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner17DagCacheContainerE">
<span id="_CPPv3N5riner17DagCacheContainerE"></span><span id="_CPPv2N5riner17DagCacheContainerE"></span><span id="riner::DagCacheContainer"></span><span class="target" id="classriner_1_1DagCacheContainer"></span><em class="property">class </em><code class="sig-name descname">DagCacheContainer</code><a class="headerlink" href="#_CPPv4N5riner17DagCacheContainerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>contains Dag Caches on the CPU which are used for verification of ethash shares </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner17DagCacheContainer8generateE8uint32_t9cByteSpanIXL32EEE">
<span id="_CPPv3N5riner17DagCacheContainer8generateE8uint32_t9cByteSpanIXL32EEE"></span><span id="_CPPv2N5riner17DagCacheContainer8generateE8uint32_t9cByteSpanIX32EE"></span><span id="riner::DagCacheContainer::generate__uint32_t.cByteSpan:32:"></span><span class="target" id="classriner_1_1DagCacheContainer_1a246eb3d83745900b7710cfa8db8af035"></span>void <code class="sig-name descname">generate</code><span class="sig-paren">(</span>uint32_t <em>epoch</em>, cByteSpan&lt;32&gt; <em>seedHash</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner17DagCacheContainer8generateE8uint32_t9cByteSpanIXL32EEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generates the dag cache for a given epoch and seedhash WARNING: takes very long, expect the call to block for a while <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">epoch</span></code>: the ethash epoch </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seedHash</span></code>: the seedHash from the ethash <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner17DagCacheContainer11isGeneratedE8uint32_t">
<span id="_CPPv3NK5riner17DagCacheContainer11isGeneratedE8uint32_t"></span><span id="_CPPv2NK5riner17DagCacheContainer11isGeneratedE8uint32_t"></span><span id="riner::DagCacheContainer::isGenerated__uint32_tC"></span><span class="target" id="classriner_1_1DagCacheContainer_1a16dc3f50dd8613374e60d942cecb5ef2"></span>bool <code class="sig-name descname">isGenerated</code><span class="sig-paren">(</span>uint32_t <em>epoch</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner17DagCacheContainer11isGeneratedE8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the dag cache was generated for <code class="docutils literal notranslate"><span class="pre">epoch</span></code> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="algoethashcl">
<h2>AlgoEthashCL<a class="headerlink" href="#algoethashcl" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner12AlgoEthashCLE">
<span id="_CPPv3N5riner12AlgoEthashCLE"></span><span id="_CPPv2N5riner12AlgoEthashCLE"></span><span id="riner::AlgoEthashCL"></span><span class="target" id="classriner_1_1AlgoEthashCL"></span><em class="property">class </em><code class="sig-name descname">AlgoEthashCL</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner9AlgorithmE" title="riner::Algorithm">Algorithm</a><a class="headerlink" href="#_CPPv4N5riner12AlgoEthashCLE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>AlgoImpl for powType “ethash” with compute Api “OpenCL” </p>
</dd></dl>

</div>
<div class="section" id="jsonserializable">
<h2>JsonSerializable<a class="headerlink" href="#jsonserializable" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenclass: Cannot find class “riner::JsonSerializable” in doxygen xml output for project “Riner” from directory: ../xml/</p>
</div>
</div>
<div class="section" id="clprogramloader">
<h2>CLProgramLoader<a class="headerlink" href="#clprogramloader" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner15CLProgramLoaderE">
<span id="_CPPv3N5riner15CLProgramLoaderE"></span><span id="_CPPv2N5riner15CLProgramLoaderE"></span><span id="riner::CLProgramLoader"></span><span class="target" id="classriner_1_1CLProgramLoader"></span><em class="property">class </em><code class="sig-name descname">CLProgramLoader</code><a class="headerlink" href="#_CPPv4N5riner15CLProgramLoaderE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner15CLProgramLoader15CLProgramLoaderENSt6stringENSt6stringE">
<span id="_CPPv3N5riner15CLProgramLoader15CLProgramLoaderENSt6stringENSt6stringE"></span><span id="_CPPv2N5riner15CLProgramLoader15CLProgramLoaderENSt6stringENSt6stringE"></span><span id="riner::CLProgramLoader::CLProgramLoader__ss.ss"></span><span class="target" id="classriner_1_1CLProgramLoader_1a2542c50235244a1e9228cc62d05983ba"></span><code class="sig-name descname">CLProgramLoader</code><span class="sig-paren">(</span>std::string <em>clSourceDir</em>, std::string <em>precompiledKernelDir</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15CLProgramLoader15CLProgramLoaderENSt6stringENSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize with a directory string for the directory which contains the opencl kernels and the directory where precompiled headers may get stored in. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner15CLProgramLoader11loadProgramEN2cl7ContextENSt6stringERKNSt6stringE">
<span id="_CPPv3N5riner15CLProgramLoader11loadProgramEN2cl7ContextENSt6stringERKNSt6stringE"></span><span id="_CPPv2N5riner15CLProgramLoader11loadProgramEN2cl7ContextENSt6stringERKNSt6stringE"></span><span id="riner::CLProgramLoader::loadProgram__cl::Context.ss.ssCR"></span><span class="target" id="classriner_1_1CLProgramLoader_1a9d296596aa5c03bafa482e13d0d00020"></span>optional&lt;cl::Program&gt; <code class="sig-name descname">loadProgram</code><span class="sig-paren">(</span>cl::Context <em>context</em>, std::string <em>clFileInKernelDir</em>, <em class="property">const</em> std::string &amp;<em>clCompilerOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15CLProgramLoader11loadProgramEN2cl7ContextENSt6stringERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>loads text from a file and compiles it to a cl::Program. This function is thread safe. (see <code class="docutils literal notranslate"><span class="pre">clCreateProgramWithSource</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">clBuildProgram</span></code> documentation for more details, as these functions are wrapped here) <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a cl::Program or nullopt if any complications happened from the loading of the file(s) to the compilation of the program. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code>: the opencl context </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clFileInKernelDir</span></code>: path to the kernel file relative to the clSourceDir provided in the constructor (which comes from the config file’s global settings ultimately) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner15CLProgramLoader11loadProgramEN2cl7ContextERKNSt6vectorINSt6stringEEERKNSt6stringE">
<span id="_CPPv3N5riner15CLProgramLoader11loadProgramEN2cl7ContextERKNSt6vectorINSt6stringEEERKNSt6stringE"></span><span id="_CPPv2N5riner15CLProgramLoader11loadProgramEN2cl7ContextERKNSt6vectorINSt6stringEEERKNSt6stringE"></span><span id="riner::CLProgramLoader::loadProgram__cl::Context.std::vector:ss:CR.ssCR"></span><span class="target" id="classriner_1_1CLProgramLoader_1a3d1291a047461859546bc54913009aab"></span>optional&lt;cl::Program&gt; <code class="sig-name descname">loadProgram</code><span class="sig-paren">(</span>cl::Context <em>context</em>, <em class="property">const</em> std::vector&lt;std::string&gt; &amp;<em>clFilesInKernelDir</em>, <em class="property">const</em> std::string &amp;<em>clCompilerOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15CLProgramLoader11loadProgramEN2cl7ContextERKNSt6vectorINSt6stringEEERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>multi-file version of <code class="docutils literal notranslate"><span class="pre">loadProgram</span></code> above </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="computemodule">
<h2>ComputeModule<a class="headerlink" href="#computemodule" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner13ComputeModuleE">
<span id="_CPPv3N5riner13ComputeModuleE"></span><span id="_CPPv2N5riner13ComputeModuleE"></span><span id="riner::ComputeModule"></span><span class="target" id="classriner_1_1ComputeModule"></span><em class="property">class </em><code class="sig-name descname">ComputeModule</code><a class="headerlink" href="#_CPPv4N5riner13ComputeModuleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner13ComputeModule13ComputeModuleERK6Config">
<span id="_CPPv3N5riner13ComputeModule13ComputeModuleERK6Config"></span><span id="_CPPv2N5riner13ComputeModule13ComputeModuleERK6Config"></span><span id="riner::ComputeModule::ComputeModule__ConfigCR"></span><span class="target" id="classriner_1_1ComputeModule_1a0a0dd30faa71d63ebfe212748a1ee896"></span><code class="sig-name descname">ComputeModule</code><span class="sig-paren">(</span><em class="property">const</em> Config &amp;<em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13ComputeModule13ComputeModuleERK6Config" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize <a class="reference internal" href="#classriner_1_1ComputeModule"><span class="std std-ref">ComputeModule</span></a> with a valid protobuf config. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">config</span></code>: config required for e.g. OpenCL kernel directory. (this function takes the entire config instead of the kernel directory string because it is forseeable that the <a class="reference internal" href="#classriner_1_1ComputeModule"><span class="std std-ref">ComputeModule</span></a> will require other config information n the future) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner13ComputeModule15getAllDeviceIdsEv">
<span id="_CPPv3NK5riner13ComputeModule15getAllDeviceIdsEv"></span><span id="_CPPv2NK5riner13ComputeModule15getAllDeviceIdsEv"></span><span id="riner::ComputeModule::getAllDeviceIdsC"></span><span class="target" id="classriner_1_1ComputeModule_1a1d98c39c1f21cd20e4f6774683742487"></span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4N5riner8DeviceIdE" title="riner::DeviceId">DeviceId</a>&gt; &amp;<code class="sig-name descname">getAllDeviceIds</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner13ComputeModule15getAllDeviceIdsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>generic (compute api agnostic) <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1DeviceId"><span class="std std-ref"><span class="pre">DeviceId</span></span></a></code>s of every viable compute device that is connected to the machine </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13ComputeModule15getDeviceOpenCLERK8DeviceId">
<span id="_CPPv3N5riner13ComputeModule15getDeviceOpenCLERK8DeviceId"></span><span id="_CPPv2N5riner13ComputeModule15getDeviceOpenCLERK8DeviceId"></span><span id="riner::ComputeModule::getDeviceOpenCL__DeviceIdCR"></span><span class="target" id="classriner_1_1ComputeModule_1a8027846591fcf863fde70f214e6734fb"></span>optional&lt;cl::Device&gt; <code class="sig-name descname">getDeviceOpenCL</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner8DeviceIdE" title="riner::DeviceId">DeviceId</a> &amp;<em>requestId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13ComputeModule15getDeviceOpenCLERK8DeviceId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>obtain the OpenCL specific device handle for a generic <a class="reference internal" href="#classriner_1_1DeviceId"><span class="std std-ref">DeviceId</span></a> will print a log message if obtaining the device fails (no logging on user side necessary) <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the corresponding <code class="docutils literal notranslate"><span class="pre">cl::Device</span></code> to the given <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1DeviceId"><span class="std std-ref"><span class="pre">DeviceId</span></span></a></code> or nullopt if no OpenCL handle is available for the generic ID (unlikely) </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13ComputeModule22getProgramLoaderOpenCLEv">
<span id="_CPPv3N5riner13ComputeModule22getProgramLoaderOpenCLEv"></span><span id="_CPPv2N5riner13ComputeModule22getProgramLoaderOpenCLEv"></span><span id="riner::ComputeModule::getProgramLoaderOpenCL"></span><span class="target" id="classriner_1_1ComputeModule_1a3c5f86bd9d1e1299f1fe362b5958fbe8"></span><a class="reference internal" href="#_CPPv4N5riner15CLProgramLoaderE" title="riner::CLProgramLoader">CLProgramLoader</a> &amp;<code class="sig-name descname">getProgramLoaderOpenCL</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13ComputeModule22getProgramLoaderOpenCLEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the ProgramLoader for OpenCL which provides convenience functionality for loading/compiling OpenCL kernels this function is thread safe, more details on the thread safety of <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1CLProgramLoader"><span class="std std-ref"><span class="pre">CLProgramLoader</span></span></a></code> in “CLProgramLoader.h” </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="deviceid">
<h2>DeviceId<a class="headerlink" href="#deviceid" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner8DeviceIdE">
<span id="_CPPv3N5riner8DeviceIdE"></span><span id="_CPPv2N5riner8DeviceIdE"></span><span id="riner::DeviceId"></span><span class="target" id="classriner_1_1DeviceId"></span><em class="property">class </em><code class="sig-name descname">DeviceId</code><a class="headerlink" href="#_CPPv4N5riner8DeviceIdE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="application">
<h2>Application<a class="headerlink" href="#application" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner11ApplicationE">
<span id="_CPPv3N5riner11ApplicationE"></span><span id="_CPPv2N5riner11ApplicationE"></span><span id="riner::Application"></span><span class="target" id="classriner_1_1Application"></span><em class="property">class </em><code class="sig-name descname">Application</code><a class="headerlink" href="#_CPPv4N5riner11ApplicationE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>class representing the application’s state (excluding <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1ShutdownState"><span class="std std-ref"><span class="pre">ShutdownState</span></span></a></code>) </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner11Application13launchProfileERK6ConfigRKN5proto14Config_ProfileE">
<span id="_CPPv3N5riner11Application13launchProfileERK6ConfigRKN5proto14Config_ProfileE"></span><span id="_CPPv2N5riner11Application13launchProfileERK6ConfigRKN5proto14Config_ProfileE"></span><span id="riner::Application::launchProfile__ConfigCR.proto::Config_ProfileCR"></span><span class="target" id="classriner_1_1Application_1a0e192a6051351f69408bced2e3a08768"></span>void <code class="sig-name descname">launchProfile</code><span class="sig-paren">(</span><em class="property">const</em> Config &amp;<em>config</em>, <em class="property">const</em> proto::Config_Profile &amp;<em>prof</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11Application13launchProfileERK6ConfigRKN5proto14Config_ProfileE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>launches a particular config profile (starts AlgoImpls, Pools, etc…) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner11Application13logLaunchInfoERKNSt6stringERNSt6vectorINSt17reference_wrapperI6DeviceEEEE">
<span id="_CPPv3NK5riner11Application13logLaunchInfoERKNSt6stringERNSt6vectorINSt17reference_wrapperI6DeviceEEEE"></span><span id="_CPPv2NK5riner11Application13logLaunchInfoERKNSt6stringERNSt6vectorINSt17reference_wrapperI6DeviceEEEE"></span><span id="riner::Application::logLaunchInfo__ssCR.std::vector:std::reference_wrapper:Device::RC"></span><span class="target" id="classriner_1_1Application_1a37006b6f317422b6751f60a765fd8bd1"></span>void <code class="sig-name descname">logLaunchInfo</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>implName</em>, std::vector&lt;std::reference_wrapper&lt;<a class="reference internal" href="#_CPPv4N5riner6DeviceE" title="riner::Device">Device</a>&gt;&gt; &amp;<em>assignedDevices</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner11Application13logLaunchInfoERKNSt6stringERNSt6vectorINSt17reference_wrapperI6DeviceEEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>logs information about the launch of a profile </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner11Application11ApplicationE6Config">
<span id="_CPPv3N5riner11Application11ApplicationE6Config"></span><span id="_CPPv2N5riner11Application11ApplicationE6Config"></span><span id="riner::Application::Application__Config"></span><span class="target" id="classriner_1_1Application_1a365fb92e42c7a916b89ad7d7387e76ca"></span><code class="sig-name descname">Application</code><span class="sig-paren">(</span>Config <em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner11Application11ApplicationE6Config" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start the <a class="reference internal" href="#classriner_1_1Application"><span class="std std-ref">Application</span></a> with a <code class="docutils literal notranslate"><span class="pre">config</span></code>, will launch the start profile specified in the config! </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N5riner11Application12devicesInUseE">
<span id="_CPPv3N5riner11Application12devicesInUseE"></span><span id="_CPPv2N5riner11Application12devicesInUseE"></span><span id="riner::Application::devicesInUse__SharedLockGuarded:std::deque:optional:Device:::"></span><span class="target" id="classriner_1_1Application_1ac5d99d38ef488b7af0eefd3e2fd66f37"></span><a class="reference internal" href="#_CPPv4I00EN5riner17SharedLockGuardedE" title="riner::SharedLockGuarded">SharedLockGuarded</a>&lt;std::deque&lt;optional&lt;<a class="reference internal" href="#_CPPv4N5riner6DeviceE" title="riner::Device">Device</a>&gt;&gt;&gt; <code class="sig-name descname">devicesInUse</code><a class="headerlink" href="#_CPPv4N5riner11Application12devicesInUseE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#structriner_1_1Device"><span class="std std-ref">Device</span></a> objects currently referenced by a running AlgoImpl. The <a class="reference internal" href="#structriner_1_1Device"><span class="std std-ref">Device</span></a> objects in the deque have matching indices to ConfigModule::getAllDeviceIds(), they contain nullopt if device is not used by any AlgoImpl.</p>
<p>The declaration implicitly assumes that the same <a class="reference internal" href="#structriner_1_1Device"><span class="std std-ref">Device</span></a> cannot be used by 2 AlgoImpls simultaneoulsy since they share the <a class="reference internal" href="#structriner_1_1AlgoSettings"><span class="std std-ref">AlgoSettings</span></a>. If this ever changes this vector must be something else. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N5riner11Application13poolSwitchersE">
<span id="_CPPv3N5riner11Application13poolSwitchersE"></span><span id="_CPPv2N5riner11Application13poolSwitchersE"></span><span id="riner::Application::poolSwitchers__SharedLockGuarded:std::map:ss.unique_ptr:PoolSwitcher:::"></span><span class="target" id="classriner_1_1Application_1a95da01e08b54c5333abc9e4f45893d1f"></span><a class="reference internal" href="#_CPPv4I00EN5riner17SharedLockGuardedE" title="riner::SharedLockGuarded">SharedLockGuarded</a>&lt;std::map&lt;std::string, unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner12PoolSwitcherE" title="riner::PoolSwitcher">PoolSwitcher</a>&gt;&gt;&gt; <code class="sig-name descname">poolSwitchers</code><a class="headerlink" href="#_CPPv4N5riner11Application13poolSwitchersE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map of <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a> (one <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref"><span class="pre">PoolSwitcher</span></span></a></code> per powType) key: powType as specified in <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1Registry"><span class="std std-ref"><span class="pre">Registry</span></span></a></code> value: the running <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref"><span class="pre">PoolSwitcher</span></span></a></code> object (never nullptr. the unique_ptr is only put there for convenient std::move) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N5riner11Application10algorithmsE">
<span id="_CPPv3N5riner11Application10algorithmsE"></span><span id="_CPPv2N5riner11Application10algorithmsE"></span><span id="riner::Application::algorithms__std::list:unique_ptr:Algorithm::"></span><span class="target" id="classriner_1_1Application_1ad12a645ffb81df08819be46e8af8b487"></span>std::list&lt;unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner9AlgorithmE" title="riner::Algorithm">Algorithm</a>&gt;&gt; <code class="sig-name descname">algorithms</code><a class="headerlink" href="#_CPPv4N5riner11Application10algorithmsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>running AlgoImpl instances. Elements are never nullptr. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N5riner11Application9apiServerE">
<span id="_CPPv3N5riner11Application9apiServerE"></span><span id="_CPPv2N5riner11Application9apiServerE"></span><span id="riner::Application::apiServer__unique_ptr:ApiServer:"></span><span class="target" id="classriner_1_1Application_1a6a214eca889ee5cda89495d90cbdafe0"></span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner9ApiServerE" title="riner::ApiServer">ApiServer</a>&gt; <code class="sig-name descname">apiServer</code><a class="headerlink" href="#_CPPv4N5riner11Application9apiServerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Json RPC 2.0 monitoring Api server. stores reference to this <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1Application"><span class="std std-ref"><span class="pre">Application</span></span></a></code> instance and accesses its members </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="registry">
<h2>Registry<a class="headerlink" href="#registry" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner8RegistryE">
<span id="_CPPv3N5riner8RegistryE"></span><span id="_CPPv2N5riner8RegistryE"></span><span id="riner::Registry"></span><span class="target" id="classriner_1_1Registry"></span><em class="property">class </em><code class="sig-name descname">Registry</code><a class="headerlink" href="#_CPPv4N5riner8RegistryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Factory class for creating AlgoImpl, PoolImpl and <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> instances given the text name </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner8Registry8RegistryEv">
<span id="_CPPv3N5riner8Registry8RegistryEv"></span><span id="_CPPv2N5riner8Registry8RegistryEv"></span><span id="riner::Registry::Registry"></span><span class="target" id="classriner_1_1Registry_1ace2a8ad16b4ff393c203d7ffb7dd6562"></span><code class="sig-name descname">Registry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner8Registry8RegistryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default constructor initializes the name&lt;-&gt;factory function mappings </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner8Registry8makeAlgoERKNSt6stringE20AlgoConstructionArgs">
<span id="_CPPv3NK5riner8Registry8makeAlgoERKNSt6stringE20AlgoConstructionArgs"></span><span id="_CPPv2NK5riner8Registry8makeAlgoERKNSt6stringE20AlgoConstructionArgs"></span><span id="riner::Registry::makeAlgo__ssCR.AlgoConstructionArgsC"></span><span class="target" id="classriner_1_1Registry_1ac9ac3dec5468c760034f9c4f57bc3388"></span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner9AlgorithmE" title="riner::Algorithm">Algorithm</a>&gt; <code class="sig-name descname">makeAlgo</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>name</em>, <a class="reference internal" href="#_CPPv4N5riner20AlgoConstructionArgsE" title="riner::AlgoConstructionArgs">AlgoConstructionArgs</a> <em>args</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner8Registry8makeAlgoERKNSt6stringE20AlgoConstructionArgs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>instantiates (runs) the AlgoImpl type that matches a name string AlgoImpl classes are written in such a way that they start mining as soon as they are instantiated and stop as they are destroyed, thus this call starts the mining process (provided the algorithm can obtain work from the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> referenced by args) </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type erased AlgoImpl or nullptr if algoImplName matches no registered AlgoImpl class </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code>: <a class="reference internal" href="#structriner_1_1AlgoConstructionArgs"><span class="std std-ref">AlgoConstructionArgs</span></a> that are forwarded into the selected AlgoImpl class’ ctor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algoImplName</span></code>: string name that specifies the AlgoImpl class </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner8Registry8makePoolERKNSt6stringE20PoolConstructionArgs">
<span id="_CPPv3NK5riner8Registry8makePoolERKNSt6stringE20PoolConstructionArgs"></span><span id="_CPPv2NK5riner8Registry8makePoolERKNSt6stringE20PoolConstructionArgs"></span><span id="riner::Registry::makePool__ssCR.PoolConstructionArgsC"></span><span class="target" id="classriner_1_1Registry_1aaf47561f4c360da9f8943783dcb4b1b3"></span>shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4PoolE" title="riner::Pool">Pool</a>&gt; <code class="sig-name descname">makePool</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>name</em>, <a class="reference internal" href="#_CPPv4N5riner20PoolConstructionArgsE" title="riner::PoolConstructionArgs">PoolConstructionArgs</a> <em>args</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner8Registry8makePoolERKNSt6stringE20PoolConstructionArgs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>factory method to construct a <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclass <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr of the pool (so that weak_ptrs of it can be distributed) or nullptr if <code class="docutils literal notranslate"><span class="pre">name</span></code> wasn’t found </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner8Registry13tryMakeGpuApiERKNSt6stringERK22GpuApiConstructionArgs">
<span id="_CPPv3NK5riner8Registry13tryMakeGpuApiERKNSt6stringERK22GpuApiConstructionArgs"></span><span id="_CPPv2NK5riner8Registry13tryMakeGpuApiERKNSt6stringERK22GpuApiConstructionArgs"></span><span id="riner::Registry::tryMakeGpuApi__ssCR.GpuApiConstructionArgsCRC"></span><span class="target" id="classriner_1_1Registry_1a6edb96f32e6bff73a9ee59bde3975fe5"></span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner6GpuApiE" title="riner::GpuApi">GpuApi</a>&gt; <code class="sig-name descname">tryMakeGpuApi</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>name</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner22GpuApiConstructionArgsE" title="riner::GpuApiConstructionArgs">GpuApiConstructionArgs</a> &amp;<em>args</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner8Registry13tryMakeGpuApiERKNSt6stringERK22GpuApiConstructionArgs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>factory method to construct a <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> subclass <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>unique_ptr containing the upcast <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> or nullptr if the <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> could not be initialized or the name wasn’t found </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner8Registry20registerAllAlgoImplsEv">
<span id="_CPPv3N5riner8Registry20registerAllAlgoImplsEv"></span><span id="_CPPv2N5riner8Registry20registerAllAlgoImplsEv"></span><span id="riner::Registry::registerAllAlgoImpls"></span><span class="target" id="classriner_1_1Registry_1a9b045ec240223847d496e59ab4fbfea3"></span>void <code class="sig-name descname">registerAllAlgoImpls</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner8Registry20registerAllAlgoImplsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>registers all AlgoImpls(), see the implementation of this method in <code class="docutils literal notranslate"><span class="pre">Registry.cpp</span></code> to add an algoImpl </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN5riner8Registry11addAlgoImplEvRKNSt6stringERKNSt6stringE">
<span id="_CPPv3I0EN5riner8Registry11addAlgoImplERKNSt6stringERKNSt6stringE"></span><span id="_CPPv2I0EN5riner8Registry11addAlgoImplERKNSt6stringERKNSt6stringE"></span><span class="target" id="classriner_1_1Registry_1aec4f9b90c67b8d3ca924b7eed1b1758d"></span>template&lt;class <code class="sig-name descname">AlgoT</code>&gt;<br />void <code class="sig-name descname">addAlgoImpl</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>algoImplName</em>, <em class="property">const</em> std::string &amp;<em>powType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5riner8Registry11addAlgoImplEvRKNSt6stringERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register an AlgoImpl type and generate a factory function for it. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AlgoT</span></code>: the type of the Algorithm subclass (e.g. <a class="reference internal" href="#classriner_1_1AlgoEthashCL"><span class="std std-ref">AlgoEthashCL</span></a>) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algoImplName</span></code>: the algo’s name as it should be referred to in the config file </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">powType</span></code>: the pow type string for checking compatibility with pools/work </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN5riner8Registry11addPoolImplEvRKNSt6stringERKNSt6stringERKNSt6stringERKNSt6stringE">
<span id="_CPPv3I0EN5riner8Registry11addPoolImplERKNSt6stringERKNSt6stringERKNSt6stringERKNSt6stringE"></span><span id="_CPPv2I0EN5riner8Registry11addPoolImplERKNSt6stringERKNSt6stringERKNSt6stringERKNSt6stringE"></span><span class="target" id="classriner_1_1Registry_1a2c6a07210105a9de0afb65e92ca70f35"></span>template&lt;class <code class="sig-name descname">PoolT</code>&gt;<br />void <code class="sig-name descname">addPoolImpl</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>poolImplName</em>, <em class="property">const</em> std::string &amp;<em>powType</em>, <em class="property">const</em> std::string &amp;<em>protocolType</em>, <em class="property">const</em> std::string &amp;<em>protocolTypeAlias</em> = &quot;&quot;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5riner8Registry11addPoolImplEvRKNSt6stringERKNSt6stringERKNSt6stringERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a PoolImpl type and generate a factory function for it. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PoolT</span></code>: the type of the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclass (e.g. <a class="reference internal" href="#classriner_1_1PoolEthashStratum"><span class="std std-ref">PoolEthashStratum</span></a>) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">poolImplName</span></code>: the pool’s name as it should be referred to in the config file </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">powType</span></code>: the pow type string for checking compatibility with pools/work </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN5riner8Registry9addGpuApiEvRKNSt6stringE">
<span id="_CPPv3I0EN5riner8Registry9addGpuApiERKNSt6stringE"></span><span id="_CPPv2I0EN5riner8Registry9addGpuApiERKNSt6stringE"></span><span class="target" id="classriner_1_1Registry_1ab4cc31e93941f831b9c5126c5c4ce0b6"></span>template&lt;class <code class="sig-name descname">GpuApiT</code>&gt;<br />void <code class="sig-name descname">addGpuApi</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>gpuApiName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5riner8Registry9addGpuApiEvRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> type and generate a factory function for it. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GpuApiT</span></code>: the type of the <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> subclass (e.g. <a class="reference internal" href="#classriner_1_1AmdgpuApi"><span class="std std-ref">AmdgpuApi</span></a>) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gpuApiName</span></code>: the the name of the <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> (used as a key) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv4N5riner8Registry9EntryAlgoE">
<span id="_CPPv3N5riner8Registry9EntryAlgoE"></span><span id="_CPPv2N5riner8Registry9EntryAlgoE"></span><span id="riner::Registry::EntryAlgo"></span><span class="target" id="structriner_1_1Registry_1_1EntryAlgo"></span><em class="property">struct </em><code class="sig-name descname">EntryAlgo</code><a class="headerlink" href="#_CPPv4N5riner8Registry9EntryAlgoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map entry that associates an AlgoImpl name with a factory function </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5riner8Registry11EntryGpuApiE">
<span id="_CPPv3N5riner8Registry11EntryGpuApiE"></span><span id="_CPPv2N5riner8Registry11EntryGpuApiE"></span><span id="riner::Registry::EntryGpuApi"></span><span class="target" id="structriner_1_1Registry_1_1EntryGpuApi"></span><em class="property">struct </em><code class="sig-name descname">EntryGpuApi</code><a class="headerlink" href="#_CPPv4N5riner8Registry11EntryGpuApiE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map entry that contains a factory function for a <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> that may fail </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5riner8Registry9EntryPoolE">
<span id="_CPPv3N5riner8Registry9EntryPoolE"></span><span id="_CPPv2N5riner8Registry9EntryPoolE"></span><span id="riner::Registry::EntryPool"></span><span class="target" id="structriner_1_1Registry_1_1EntryPool"></span><em class="property">struct </em><code class="sig-name descname">EntryPool</code><a class="headerlink" href="#_CPPv4N5riner8Registry9EntryPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map entry that associates a PoolImpl name with a factory function </p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="apiserver">
<h2>ApiServer<a class="headerlink" href="#apiserver" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9ApiServerE">
<span id="_CPPv3N5riner9ApiServerE"></span><span id="_CPPv2N5riner9ApiServerE"></span><span id="riner::ApiServer"></span><span class="target" id="classriner_1_1ApiServer"></span><em class="property">class </em><code class="sig-name descname">ApiServer</code><a class="headerlink" href="#_CPPv4N5riner9ApiServerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>runs a Json RPC 2.0 api which exposes the methods described in the <code class="docutils literal notranslate"><span class="pre">registerFunctions()</span></code> implementation </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner9ApiServer9ApiServerE8uint16_tRK11Application">
<span id="_CPPv3N5riner9ApiServer9ApiServerE8uint16_tRK11Application"></span><span id="_CPPv2N5riner9ApiServer9ApiServerE8uint16_tRK11Application"></span><span id="riner::ApiServer::ApiServer__uint16_t.ApplicationCR"></span><span class="target" id="classriner_1_1ApiServer_1a45d1b02cbfbdcad2e2a8dfe2ceb76234"></span><code class="sig-name descname">ApiServer</code><span class="sig-paren">(</span>uint16_t <em>port</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner11ApplicationE" title="riner::Application">Application</a> &amp;<em>app</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9ApiServer9ApiServerE8uint16_tRK11Application" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start the <a class="reference internal" href="#classriner_1_1ApiServer"><span class="std std-ref">ApiServer</span></a> on the local machine and start listening on port <code class="docutils literal notranslate"><span class="pre">port</span></code>. The <a class="reference internal" href="#classriner_1_1ApiServer"><span class="std std-ref">ApiServer</span></a> will start running as soon as the constructor is called and will join its thread in the (blocking) destructor call, which means the <a class="reference internal" href="#classriner_1_1ApiServer"><span class="std std-ref">ApiServer</span></a> is alive as long as the instance is alive. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">port</span></code>: the port on which the <a class="reference internal" href="#classriner_1_1ApiServer"><span class="std std-ref">ApiServer</span></a> should listen for incoming connections (usually provided by the user in the <code class="docutils literal notranslate"><span class="pre">Config</span></code>’s general settings </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">app</span></code>: reference that goes back to the application object (which the <a class="reference internal" href="#classriner_1_1ApiServer"><span class="std std-ref">ApiServer</span></a> has friend access rights to, in order to communicate the application’s state in detail) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner9ApiServerD0Ev">
<span id="_CPPv3N5riner9ApiServerD0Ev"></span><span id="_CPPv2N5riner9ApiServerD0Ev"></span><span id="riner::ApiServer::~ApiServer"></span><span class="target" id="classriner_1_1ApiServer_1a8102710e55ede44aa385c1413fc67b6f"></span><code class="sig-name descname">~ApiServer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9ApiServerD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>blocking, terminates all connections and joins the <a class="reference internal" href="#classriner_1_1ApiServer"><span class="std std-ref">ApiServer</span></a> io thread. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner9ApiServer17registerFunctionsEv">
<span id="_CPPv3N5riner9ApiServer17registerFunctionsEv"></span><span id="_CPPv2N5riner9ApiServer17registerFunctionsEv"></span><span id="riner::ApiServer::registerFunctions"></span><span class="target" id="classriner_1_1ApiServer_1ac4af2d1336e31266e7bba1e0db6b9b8f"></span>void <code class="sig-name descname">registerFunctions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9ApiServer17registerFunctionsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>take a look at this function’s implementation to see which methods are available and/or add methods </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="work">
<h2>Work<a class="headerlink" href="#work" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4WorkE">
<span id="_CPPv3N5riner4WorkE"></span><span id="_CPPv2N5riner4WorkE"></span><span id="riner::Work"></span><span class="target" id="classriner_1_1Work"></span><em class="property">class </em><code class="sig-name descname">Work</code><a class="headerlink" href="#_CPPv4N5riner4WorkE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>base class for all classes representing a unit of work of a POWtype as provided by the pool protocol (e.g. see <a class="reference internal" href="#classriner_1_1WorkEthash"><span class="std std-ref">WorkEthash</span></a>) this unit of work does not necessarily correspond to e.g. a stratum job, it may be a work representation of smaller granularity. The pool protocol implementation is incentivized to make this work of appropriate size (read: amount of work, not byte size) so that minimal overhead is required on the AlgoImpl side to make use of it. Data that is specific to <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> protocol implementations may not be added to a <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> subclass, but rather to a <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> subclass </p>
<p>Subclassed by <a class="reference internal" href="#classriner_1_1WorkCuckoo"><span class="std std-ref">riner::WorkCuckoo&lt; PowTypeT &gt;</span></a>, <a class="reference internal" href="#structriner_1_1WorkDummy"><span class="std std-ref">riner::WorkDummy</span></a>, <a class="reference internal" href="#classriner_1_1WorkEthash"><span class="std std-ref">riner::WorkEthash</span></a>, <a class="reference internal" href="#classriner_1_1WorkCuckoo"><span class="std std-ref">riner::WorkCuckoo&lt; HasPowTypeCuckatoo&lt; 31 &gt; &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4I0EN5riner4Work8downCastEP1Tv">
<span id="_CPPv3I0EN5riner4Work8downCastEv"></span><span id="_CPPv2I0EN5riner4Work8downCastEv"></span><span class="target" id="classriner_1_1Work_1a88362c632890917738d38bd7f48ca036"></span>template&lt;class <code class="sig-name descname">T</code>&gt;<br /><a class="reference internal" href="#_CPPv4I0EN5riner4Work8downCastEP1Tv" title="riner::Work::downCast::T">T</a> *<code class="sig-name descname">downCast</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5riner4Work8downCastEP1Tv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>functions like a dynamic_cast but doesn’t rely on RTTI </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0ENK5riner4Work8downCastEPK1Tv">
<span id="_CPPv3I0ENK5riner4Work8downCastEv"></span><span id="_CPPv2I0ENK5riner4Work8downCastEv"></span><span class="target" id="classriner_1_1Work_1a15063f543b7b0bb09783b6901f21c056"></span>template&lt;class <code class="sig-name descname">T</code>&gt;<br /><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN5riner4Work8downCastEP1Tv" title="riner::Work::downCast::T">T</a> *<code class="sig-name descname">downCast</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4I0ENK5riner4Work8downCastEPK1Tv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>const version of the above function </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4Work9tryGetJobEv">
<span id="_CPPv3NK5riner4Work9tryGetJobEv"></span><span id="_CPPv2NK5riner4Work9tryGetJobEv"></span><span id="riner::Work::tryGetJobC"></span><span class="target" id="classriner_1_1Work_1acb8906d677b848092ab34cf3ab05f8d8"></span>std::shared_ptr&lt;<em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a>&gt; <code class="sig-name descname">tryGetJob</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Work9tryGetJobEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the associated poolJob or nullptr if the job expired </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4Work7expiredEv">
<span id="_CPPv3NK5riner4Work7expiredEv"></span><span id="_CPPv2NK5riner4Work7expiredEv"></span><span id="riner::Work::expiredC"></span><span class="target" id="classriner_1_1Work_1a6c7548c706c0cbde4bdce5fca33b82e2"></span>bool <code class="sig-name descname">expired</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Work7expiredEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>checks whether work is no longer the most recent work available to the pool protocol. <a class="reference internal" href="#classriner_1_1Work_1a6c7548c706c0cbde4bdce5fca33b82e2"><span class="std std-ref">expired()</span></a> can be used as hint for algorithms whether new work shall be requested from the pool. Upon expiration it is expected (but not necessary) that an algorithm stops working on this work, if fresh work can be acquired from the pool. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the work has been marked expired by the pool protocol implementation </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4Work5validEv">
<span id="_CPPv3NK5riner4Work5validEv"></span><span id="_CPPv2NK5riner4Work5validEv"></span><span id="riner::Work::validC"></span><span class="target" id="classriner_1_1Work_1a263b7823ebb629e6801c1e09568d8599"></span>bool <code class="sig-name descname">valid</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Work5validEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>checks whether solutions of this work would be still accepted by the pool protocol. if <a class="reference internal" href="#classriner_1_1Work_1a263b7823ebb629e6801c1e09568d8599"><span class="std std-ref">valid()</span></a> returns false, then it does not make sense to continue finding solutions for this work. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether a solution for this work would be accepted by the pool protocol implementation </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0ENK5riner4Work16makeWorkSolutionE10unique_ptrI13WorkSolutionTEv">
<span id="_CPPv3I0ENK5riner4Work16makeWorkSolutionEv"></span><span id="_CPPv2I0ENK5riner4Work16makeWorkSolutionEv"></span><span class="target" id="classriner_1_1Work_1a8a7018ce9cf7c2c516da10695f91a0b1"></span>template&lt;class <code class="sig-name descname">WorkSolutionT</code>&gt;<br />unique_ptr&lt;<a class="reference internal" href="#_CPPv4I0ENK5riner4Work16makeWorkSolutionE10unique_ptrI13WorkSolutionTEv" title="riner::Work::makeWorkSolution::WorkSolutionT">WorkSolutionT</a>&gt; <code class="sig-name descname">makeWorkSolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4I0ENK5riner4Work16makeWorkSolutionE10unique_ptrI13WorkSolutionTEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates a solution object for this work object. creates a solution object which can be filled with the algorithm results to then be submitted to the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a>. There can be many <a class="reference internal" href="#classriner_1_1WorkSolution"><span class="std std-ref">WorkSolution</span></a> objects generated from a single <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> instance. A solution object does not necessarily need to be submitted. <a class="reference internal" href="#classriner_1_1WorkSolution"><span class="std std-ref">WorkSolution</span></a> objects must be created through this function in order to be properly tied to a <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> object (via the private job member) That way the PoolImpl can track which solution belongs to which work package. A pool can make work objects expire (which can be queried via <a class="reference internal" href="#classriner_1_1Work_1a6c7548c706c0cbde4bdce5fca33b82e2"><span class="std std-ref">Work::expired()</span></a>). This may be used as a hint to abort any calculations and acquire a new work object, however it is not required to do so. There is no obligation to check for expiration before submitting a solution </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a WorkSolutionT wrapped in a unique_ptr in order to allow passing it later in a type erased fashion (as unique_ptr&lt;WorkSolution&gt;) without slicing </p>
</dd>
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">WorkSolutionT</span></code>: Type of the Solution object that corresponds to this work’s dynamic type (e.g. <a class="reference internal" href="#classriner_1_1WorkSolutionEthash"><span class="std std-ref">WorkSolutionEthash</span></a> for <a class="reference internal" href="#classriner_1_1WorkEthash"><span class="std std-ref">WorkEthash</span></a>).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="worksolution">
<h2>WorkSolution<a class="headerlink" href="#worksolution" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner12WorkSolutionE">
<span id="_CPPv3N5riner12WorkSolutionE"></span><span id="_CPPv2N5riner12WorkSolutionE"></span><span id="riner::WorkSolution"></span><span class="target" id="classriner_1_1WorkSolution"></span><em class="property">class </em><code class="sig-name descname">WorkSolution</code><a class="headerlink" href="#_CPPv4N5riner12WorkSolutionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Solution counterpart of the <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> class. Every <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> subclass is expected to have a corresponding <a class="reference internal" href="#classriner_1_1WorkSolution"><span class="std std-ref">WorkSolution</span></a> subclass for a given POWtype. WorkSolutions should be created via a <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a>’s makeWorkSolution&lt;T&gt;() method, then be filled with the actual proof of work data and then submitted to the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a>. </p>
<p>Subclassed by <a class="reference internal" href="#classriner_1_1WorkSolutionCuckoo"><span class="std std-ref">riner::WorkSolutionCuckoo&lt; PowTypeT &gt;</span></a>, <a class="reference internal" href="#structriner_1_1WorkSolutionDummy"><span class="std std-ref">riner::WorkSolutionDummy</span></a>, <a class="reference internal" href="#classriner_1_1WorkSolutionEthash"><span class="std std-ref">riner::WorkSolutionEthash</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4I0ENK5riner12WorkSolution11tryGetJobAsENSt10shared_ptrIK1TEEv">
<span id="_CPPv3I0ENK5riner12WorkSolution11tryGetJobAsEv"></span><span id="_CPPv2I0ENK5riner12WorkSolution11tryGetJobAsEv"></span><span class="target" id="classriner_1_1WorkSolution_1a1f71eb6b8d48ecdaa6edaeb8f46412de"></span>template&lt;class <code class="sig-name descname">T</code>&gt;<br />std::shared_ptr&lt;<em class="property">const</em> <a class="reference internal" href="#_CPPv4I0ENK5riner12WorkSolution11tryGetJobAsENSt10shared_ptrIK1TEEv" title="riner::WorkSolution::tryGetJobAs::T">T</a>&gt; <code class="sig-name descname">tryGetJobAs</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4I0ENK5riner12WorkSolution11tryGetJobAsENSt10shared_ptrIK1TEEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convenience method to get <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> cast to one of its subclasses <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Job as T or nullptr if !this-&gt;<a class="reference internal" href="#classriner_1_1WorkSolution_1a3db1ab78caf2dceb5fc3c4d44c8fa2c8"><span class="std std-ref">valid()</span></a> </p>
</dd>
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN5riner12WorkSolution8downCastEP1Tv">
<span id="_CPPv3I0EN5riner12WorkSolution8downCastEv"></span><span id="_CPPv2I0EN5riner12WorkSolution8downCastEv"></span><span class="target" id="classriner_1_1WorkSolution_1a5671726773a0d37bb6a5e1d8936a40b8"></span>template&lt;class <code class="sig-name descname">T</code>&gt;<br /><a class="reference internal" href="#_CPPv4I0EN5riner12WorkSolution8downCastEP1Tv" title="riner::WorkSolution::downCast::T">T</a> *<code class="sig-name descname">downCast</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5riner12WorkSolution8downCastEP1Tv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>functions like a dynamic_cast but doesn’t rely on RTTI </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0ENK5riner12WorkSolution8downCastEPK1Tv">
<span id="_CPPv3I0ENK5riner12WorkSolution8downCastEv"></span><span id="_CPPv2I0ENK5riner12WorkSolution8downCastEv"></span><span class="target" id="classriner_1_1WorkSolution_1a7d38a147a9624908655b7d952893579a"></span>template&lt;class <code class="sig-name descname">T</code>&gt;<br /><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN5riner12WorkSolution8downCastEP1Tv" title="riner::WorkSolution::downCast::T">T</a> *<code class="sig-name descname">downCast</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4I0ENK5riner12WorkSolution8downCastEPK1Tv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>const version of the above function </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner12WorkSolution7expiredEv">
<span id="_CPPv3NK5riner12WorkSolution7expiredEv"></span><span id="_CPPv2NK5riner12WorkSolution7expiredEv"></span><span id="riner::WorkSolution::expiredC"></span><span class="target" id="classriner_1_1WorkSolution_1aebd9c2e5caa1e7fc0d176b06c8da6815"></span>bool <code class="sig-name descname">expired</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner12WorkSolution7expiredEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>checks whether solution belongs to the most recent work available to the pool protocol. Usually, an expired solution should be accepted by the pool protocol implementation, too. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the solution has been marked expired by the pool protocol implementation </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner12WorkSolution5validEv">
<span id="_CPPv3NK5riner12WorkSolution5validEv"></span><span id="_CPPv2NK5riner12WorkSolution5validEv"></span><span id="riner::WorkSolution::validC"></span><span class="target" id="classriner_1_1WorkSolution_1a3db1ab78caf2dceb5fc3c4d44c8fa2c8"></span>bool <code class="sig-name descname">valid</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner12WorkSolution5validEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>checks whether solution would be still accepted by the pool protocol. if <a class="reference internal" href="#classriner_1_1WorkSolution_1a3db1ab78caf2dceb5fc3c4d44c8fa2c8"><span class="std std-ref">valid()</span></a> returns false, then the solution will be rejected by the pool protocol implementation. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether solution would be accepted by the pool protocol implementation </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="workethash">
<h2>WorkEthash<a class="headerlink" href="#workethash" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner10WorkEthashE">
<span id="_CPPv3N5riner10WorkEthashE"></span><span id="_CPPv2N5riner10WorkEthashE"></span><span id="riner::WorkEthash"></span><span class="target" id="classriner_1_1WorkEthash"></span><em class="property">class </em><code class="sig-name descname">WorkEthash</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>, <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner16HasPowTypeEthashE" title="riner::HasPowTypeEthash">HasPowTypeEthash</a><a class="headerlink" href="#_CPPv4N5riner10WorkEthashE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner10WorkEthash8setEpochEv">
<span id="_CPPv3N5riner10WorkEthash8setEpochEv"></span><span id="_CPPv2N5riner10WorkEthash8setEpochEv"></span><span id="riner::WorkEthash::setEpoch"></span><span class="target" id="classriner_1_1WorkEthash_1a72400c81e2e6f8d17537362b089387ea"></span>void <code class="sig-name descname">setEpoch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner10WorkEthash8setEpochEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>setEpoch is called on the work templte in the Ethash <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a>’s workQueue, so that the epoch calculation doesn’t happen on the io thread, but the queue’s refill thread instead </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner10WorkEthash25setDifficultiesAndTargetsERK5BytesIXL32EEE">
<span id="_CPPv3N5riner10WorkEthash25setDifficultiesAndTargetsERK5BytesIXL32EEE"></span><span id="_CPPv2N5riner10WorkEthash25setDifficultiesAndTargetsERK5BytesIX32EE"></span><span id="riner::WorkEthash::setDifficultiesAndTargets__Bytes:32:CR"></span><span class="target" id="classriner_1_1WorkEthash_1a18eab1c5b15325fd3498cd7fe6502af4"></span>void <code class="sig-name descname">setDifficultiesAndTargets</code><span class="sig-paren">(</span><em class="property">const</em> Bytes&lt;32&gt; &amp;<em>jobTarget</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner10WorkEthash25setDifficultiesAndTargetsERK5BytesIXL32EEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>called to finish initializing by setting difficulty related members </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="worksolutionethash">
<h2>WorkSolutionEthash<a class="headerlink" href="#worksolutionethash" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner18WorkSolutionEthashE">
<span id="_CPPv3N5riner18WorkSolutionEthashE"></span><span id="_CPPv2N5riner18WorkSolutionEthashE"></span><span id="riner::WorkSolutionEthash"></span><span class="target" id="classriner_1_1WorkSolutionEthash"></span><em class="property">class </em><code class="sig-name descname">WorkSolutionEthash</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner12WorkSolutionE" title="riner::WorkSolution">WorkSolution</a>, <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner16HasPowTypeEthashE" title="riner::HasPowTypeEthash">HasPowTypeEthash</a><a class="headerlink" href="#_CPPv4N5riner18WorkSolutionEthashE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="stillalivetrackable">
<h2>StillAliveTrackable<a class="headerlink" href="#stillalivetrackable" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner19StillAliveTrackableE">
<span id="_CPPv3N5riner19StillAliveTrackableE"></span><span id="_CPPv2N5riner19StillAliveTrackableE"></span><span id="riner::StillAliveTrackable"></span><span class="target" id="classriner_1_1StillAliveTrackable"></span><em class="property">class </em><code class="sig-name descname">StillAliveTrackable</code><a class="headerlink" href="#_CPPv4N5riner19StillAliveTrackableE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>pools extend this class to offer timestamp information of last incoming message to a <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a> that way decisions can be made about which pool to prefer and which pool became inactive </p>
<p>Subclassed by <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">riner::Pool</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner19StillAliveTrackable21getLastKnownAliveTimeEv">
<span id="_CPPv3N5riner19StillAliveTrackable21getLastKnownAliveTimeEv"></span><span id="_CPPv2N5riner19StillAliveTrackable21getLastKnownAliveTimeEv"></span><span id="riner::StillAliveTrackable::getLastKnownAliveTime"></span><span class="target" id="classriner_1_1StillAliveTrackable_1a7a7594a0d6b7f31ecca91bb6f6eafd16"></span><a class="reference internal" href="#_CPPv4N5riner19StillAliveTrackableE" title="riner::StillAliveTrackable">StillAliveTrackable</a>::clock::time_point <code class="sig-name descname">getLastKnownAliveTime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner19StillAliveTrackable21getLastKnownAliveTimeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the timestamp of the most recent onStillAlive call this method may be called from any thread </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner19StillAliveTrackable21getObjectCreationTimeEv">
<span id="_CPPv3N5riner19StillAliveTrackable21getObjectCreationTimeEv"></span><span id="_CPPv2N5riner19StillAliveTrackable21getObjectCreationTimeEv"></span><span id="riner::StillAliveTrackable::getObjectCreationTime"></span><span class="target" id="classriner_1_1StillAliveTrackable_1a0fed34322f266c0b823f8f3ea90fbe08"></span><a class="reference internal" href="#_CPPv4N5riner19StillAliveTrackableE" title="riner::StillAliveTrackable">StillAliveTrackable</a>::clock::time_point <code class="sig-name descname">getObjectCreationTime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner19StillAliveTrackable21getObjectCreationTimeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the timestamp of when this base class was initialized in an object this method may be called from any thread </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner19StillAliveTrackable7setDeadEb">
<span id="_CPPv3N5riner19StillAliveTrackable7setDeadEb"></span><span id="_CPPv2N5riner19StillAliveTrackable7setDeadEb"></span><span id="riner::StillAliveTrackable::setDead__b"></span><span class="target" id="classriner_1_1StillAliveTrackable_1afdc66f78639f47c98866141e2203f597"></span>void <code class="sig-name descname">setDead</code><span class="sig-paren">(</span>bool <em>isDead</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner19StillAliveTrackable7setDeadEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>if the lastKnownAliveTime is considered to long ago, this function is called to declare this object ‘dead’ (and call onDeclaredDead internally). If subsequent OnStillAlive messages have been noticed, the dead state will be revoked </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner19StillAliveTrackable6isDeadEv">
<span id="_CPPv3NK5riner19StillAliveTrackable6isDeadEv"></span><span id="_CPPv2NK5riner19StillAliveTrackable6isDeadEv"></span><span id="riner::StillAliveTrackable::isDeadC"></span><span class="target" id="classriner_1_1StillAliveTrackable_1ab5bda879341abcc74ca5455166eef594"></span>bool <code class="sig-name descname">isDead</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner19StillAliveTrackable6isDeadEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>if the object’s alive times suggest it has reawakened after it was declared dead this function is called </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner19StillAliveTrackable25getLatestDeclaredDeadTimeEv">
<span id="_CPPv3N5riner19StillAliveTrackable25getLatestDeclaredDeadTimeEv"></span><span id="_CPPv2N5riner19StillAliveTrackable25getLatestDeclaredDeadTimeEv"></span><span id="riner::StillAliveTrackable::getLatestDeclaredDeadTime"></span><span class="target" id="classriner_1_1StillAliveTrackable_1a964aaf061c68c879a5f4d959bce530bd"></span><a class="reference internal" href="#_CPPv4N5riner19StillAliveTrackableE" title="riner::StillAliveTrackable">StillAliveTrackable</a>::clock::time_point <code class="sig-name descname">getLatestDeclaredDeadTime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner19StillAliveTrackable25getLatestDeclaredDeadTimeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the timestamp of the most recent onDeclaredDead call this method may be called from any thread </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner19StillAliveTrackable21setLastKnownAliveTimeEN5clock10time_pointE">
<span id="_CPPv3N5riner19StillAliveTrackable21setLastKnownAliveTimeEN5clock10time_pointE"></span><span id="_CPPv2N5riner19StillAliveTrackable21setLastKnownAliveTimeEN5clock10time_pointE"></span><span id="riner::StillAliveTrackable::setLastKnownAliveTime__clock::time_point"></span><span class="target" id="classriner_1_1StillAliveTrackable_1a5a2ed2c209728d12fcf6f1c268cb8a0c"></span>void <code class="sig-name descname">setLastKnownAliveTime</code><span class="sig-paren">(</span>clock::time_point <em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner19StillAliveTrackable21setLastKnownAliveTimeEN5clock10time_pointE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>manually change the timestamp that tracks the most recent onStillAlive call this method may be called from any thread <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: new value that overwrites the existing timestamp value </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner19StillAliveTrackable12onStillAliveEv">
<span id="_CPPv3N5riner19StillAliveTrackable12onStillAliveEv"></span><span id="_CPPv2N5riner19StillAliveTrackable12onStillAliveEv"></span><span id="riner::StillAliveTrackable::onStillAlive"></span><span class="target" id="classriner_1_1StillAliveTrackable_1ab076ce95ca19d172692f47270c7da854"></span>void <code class="sig-name descname">onStillAlive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner19StillAliveTrackable12onStillAliveEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call this if you just received an incoming message from the network, it will update the internal timestamp this method may be called from any thread </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="pool">
<h2>Pool<a class="headerlink" href="#pool" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4PoolE">
<span id="_CPPv3N5riner4PoolE"></span><span id="_CPPv2N5riner4PoolE"></span><span id="riner::Pool"></span><span class="target" id="classriner_1_1Pool"></span><em class="property">class </em><code class="sig-name descname">Pool</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner19StillAliveTrackableE" title="riner::StillAliveTrackable">StillAliveTrackable</a><a class="headerlink" href="#_CPPv4N5riner4PoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>common base class for all <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> protocol implementations when subclassing <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a>, do not forget to add your PoolImpl class to the registry in ‘Registry.cpp’ </p>
<p>Subclassed by <a class="reference internal" href="#classriner_1_1PoolDummy"><span class="std std-ref">riner::PoolDummy</span></a>, <a class="reference internal" href="#classriner_1_1PoolEthashStratum"><span class="std std-ref">riner::PoolEthashStratum</span></a>, <a class="reference internal" href="#classriner_1_1PoolGrinStratum"><span class="std std-ref">riner::PoolGrinStratum</span></a>, <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">riner::PoolSwitcher</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5riner4Pool11readRecordsEv">
<span id="_CPPv3NK5riner4Pool11readRecordsEv"></span><span id="_CPPv2NK5riner4Pool11readRecordsEv"></span><span id="riner::Pool::readRecordsC"></span><span class="target" id="classriner_1_1Pool_1a75f9e18bba7678c63a2f9588ac5b4e3f"></span>auto <code class="sig-name descname">readRecords</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Pool11readRecordsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a copy of current <a class="reference internal" href="#classriner_1_1PoolRecords"><span class="std std-ref">PoolRecords</span></a> data state </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool18addRecordsListenerER11PoolRecords">
<span id="_CPPv3N5riner4Pool18addRecordsListenerER11PoolRecords"></span><span id="_CPPv2N5riner4Pool18addRecordsListenerER11PoolRecords"></span><span id="riner::Pool::addRecordsListener__PoolRecordsR"></span><span class="target" id="classriner_1_1Pool_1ac50c21613ed1c0f0d513d975dfb5b4f8"></span>void <code class="sig-name descname">addRecordsListener</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5riner11PoolRecordsE" title="riner::PoolRecords">PoolRecords</a> &amp;<em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4Pool18addRecordsListenerER11PoolRecords" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>adds a listener to the <a class="reference internal" href="#classriner_1_1PoolRecords"><span class="std std-ref">PoolRecords</span></a> associated with this pool, which can aggregate stat changes </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool18setOnStateChangeCvENSt10shared_ptrINSt18condition_variableEEE">
<span id="_CPPv3N5riner4Pool18setOnStateChangeCvENSt10shared_ptrINSt18condition_variableEEE"></span><span id="_CPPv2N5riner4Pool18setOnStateChangeCvENSt10shared_ptrINSt18condition_variableEEE"></span><span id="riner::Pool::setOnStateChangeCv__std::shared_ptr:std::condition_variable:"></span><span class="target" id="classriner_1_1Pool_1aa787c39ab4a7bb5c6bd970185e7dd988"></span>void <code class="sig-name descname">setOnStateChangeCv</code><span class="sig-paren">(</span>std::shared_ptr&lt;std::condition_variable&gt; <em>cv</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4Pool18setOnStateChangeCvENSt10shared_ptrINSt18condition_variableEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sets the onStateChange condition variable, so that the calling thread can be notified later </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4Pool7getNameEv">
<span id="_CPPv3NK5riner4Pool7getNameEv"></span><span id="_CPPv2NK5riner4Pool7getNameEv"></span><span id="riner::Pool::getNameC"></span><span class="target" id="classriner_1_1Pool_1ade3060d208d7ffbe6b8fbabc22cd88f2"></span><em class="property">virtual</em> std::string <code class="sig-name descname">getName</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Pool7getNameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>host:port in a printable way </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool12isExpiredJobERK7PoolJob">
<span id="_CPPv3N5riner4Pool12isExpiredJobERK7PoolJob"></span><span id="_CPPv2N5riner4Pool12isExpiredJobERK7PoolJob"></span><span id="riner::Pool::isExpiredJob__PoolJobCR"></span><span class="target" id="classriner_1_1Pool_1aeb7264f6ce4ba14edb9048b9219ce0c1"></span><em class="property">virtual</em> bool <code class="sig-name descname">isExpiredJob</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a> &amp;<em>job</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5riner4Pool12isExpiredJobERK7PoolJob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the pool job is considered expired. Most implementations forward this call to the <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a>’s <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1WorkQueue_1ab5e87298dc5d553bb80b0626a0c2f95e"><span class="std std-ref"><span class="pre">WorkQueue::isExpiredJob()</span></span></a></code> method, which returns false as soon as a newer job was pushed. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool10expireJobsEv">
<span id="_CPPv3N5riner4Pool10expireJobsEv"></span><span id="_CPPv2N5riner4Pool10expireJobsEv"></span><span id="riner::Pool::expireJobs"></span><span class="target" id="classriner_1_1Pool_1a7bbc26f79f0f1828b1df43b7ba2ee2fa"></span><em class="property">virtual</em> void <code class="sig-name descname">expireJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5riner4Pool10expireJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>on pool switch this method is called by the <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a>, so that all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> from this pool is marked as expired and the GPUs request new work after this </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool9clearJobsEv">
<span id="_CPPv3N5riner4Pool9clearJobsEv"></span><span id="_CPPv2N5riner4Pool9clearJobsEv"></span><span id="riner::Pool::clearJobs"></span><span class="target" id="classriner_1_1Pool_1a94145f2e250129c2bedf31d347645dbf"></span><em class="property">virtual</em> void <code class="sig-name descname">clearJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5riner4Pool9clearJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clears the job queue and therefore all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> and <a class="reference internal" href="#classriner_1_1WorkSolution"><span class="std std-ref">WorkSolution</span></a> from this pool is invalidated. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool9setActiveEb">
<span id="_CPPv3N5riner4Pool9setActiveEb"></span><span id="_CPPv2N5riner4Pool9setActiveEb"></span><span id="riner::Pool::setActive__b"></span><span class="target" id="classriner_1_1Pool_1aeee8f4a45b27251eb03f2c7b3ef106ab"></span>void <code class="sig-name descname">setActive</code><span class="sig-paren">(</span>bool <em>active</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4Pool9setActiveEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This method is called by the <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a> and it changes the active status of the pool As long as the active flag is cleared no connection attempt to the pool shall be made and when the flag is cleared, then the current connection is closed immediately. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">active</span></code>: new value of active flag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool14onDeclaredDeadEv">
<span id="_CPPv3N5riner4Pool14onDeclaredDeadEv"></span><span id="_CPPv2N5riner4Pool14onDeclaredDeadEv"></span><span id="riner::Pool::onDeclaredDead"></span><span class="target" id="classriner_1_1Pool_1a28cf9d99e0b8179c5c766ab5003f863c"></span><em class="property">virtual</em> void <code class="sig-name descname">onDeclaredDead</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5riner4Pool14onDeclaredDeadEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The pool switcher will declare pools dead if they didn’t respond for a certain amount of time. PoolImpls are supposed to call <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1StillAliveTrackable_1ab076ce95ca19d172692f47270c7da854"><span class="std std-ref"><span class="pre">StillAliveTrackable::onStillAlive</span></span></a></code> every time they receive a message from the pool. The <a class="reference internal" href="#classriner_1_1StillAliveTrackable"><span class="std std-ref">StillAliveTrackable</span></a> interface is used to figure out whether to declare a pool dead. Once it is declared dead the PoolImpl can react by overloading this function and trying to disconnect and reconnect to the pool. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool14tryGetWorkImplEv">
<span id="_CPPv3N5riner4Pool14tryGetWorkImplEv"></span><span id="_CPPv2N5riner4Pool14tryGetWorkImplEv"></span><span id="riner::Pool::tryGetWorkImpl"></span><span class="target" id="classriner_1_1Pool_1a1f4ebf9e17d04dd64ad970e0b5d13bd8"></span><em class="property">virtual</em> unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">tryGetWorkImpl</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5riner4Pool14tryGetWorkImplEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tryGetWorkImpl call as implemented by the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclasses (aka PoolImpls) </p>
<p>this method is only supposed to be called by the templated <a class="reference internal" href="#classriner_1_1Pool_1a659d022caf0ef6d2adb140ce06415a4f"><span class="std std-ref">tryGetWork&lt;WorkT&gt;()</span></a> method below. this method tries to return valid work as quickly as possible, but also blocks for a short amount of time to wait for work to become available if it isn’t already when the call is being made. After a short timeout period with still no work available, nullptr is returned. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type erased valid unique_ptr or nullptr </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool18submitSolutionImplE10unique_ptrI12WorkSolutionE">
<span id="_CPPv3N5riner4Pool18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="_CPPv2N5riner4Pool18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="riner::Pool::submitSolutionImpl__unique_ptr:WorkSolution:"></span><span class="target" id="classriner_1_1Pool_1a35a0e8857fba84fa6b48564c0776139c"></span><em class="property">virtual</em> void <code class="sig-name descname">submitSolutionImpl</code><span class="sig-paren">(</span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner12WorkSolutionE" title="riner::WorkSolution">WorkSolution</a>&gt; <em>solution</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5riner4Pool18submitSolutionImplE10unique_ptrI12WorkSolutionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>submitSolutionImpl call as implemented by the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclasses (aka PoolImpls) </p>
<p>this method is only supposed to be called by the templated <a class="reference internal" href="#classriner_1_1Pool_1a0ab096aab54d372b668abc1c1b0663b7"><span class="std std-ref">submitSolution&lt;WorkSolutionT&gt;()</span></a> method below. this method takes the ownership of the given solution and starts its async submission, so that this method can return quickly without blocking. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solution</span></code>: the solution to be submitted to the pool </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN5riner4Pool10tryGetWorkE10unique_ptrI5WorkTEv">
<span id="_CPPv3I0EN5riner4Pool10tryGetWorkEv"></span><span id="_CPPv2I0EN5riner4Pool10tryGetWorkEv"></span><span class="target" id="classriner_1_1Pool_1a659d022caf0ef6d2adb140ce06415a4f"></span>template&lt;class <code class="sig-name descname">WorkT</code>&gt;<br />unique_ptr&lt;<a class="reference internal" href="#_CPPv4I0EN5riner4Pool10tryGetWorkE10unique_ptrI5WorkTEv" title="riner::Pool::tryGetWork::WorkT">WorkT</a>&gt; <code class="sig-name descname">tryGetWork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5riner4Pool10tryGetWorkE10unique_ptrI5WorkTEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>obtain work from a pool </p>
<p>this method is supposed to be called from within an AlgoImpl. It is the intended way of obtaining work from a pool this method tries to return valid work as quickly as possible, but also blocks for a short amount of time to wait for work to become available if it isn’t already when the call is being made. After a short timeout period with still no work available, nullptr is returned. This method is supposed to be called repeatedly in a loop in AlgoImpls, and will not cause busy waiting if nullopt is returned repeatedly due to its internal timeout mechanism</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a valid unique_ptr containing work or a nullptr </p>
</dd>
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">WorkT</span></code>: the <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> subclass for a specific POWtype </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN5riner4Pool14submitSolutionEv10unique_ptrI13WorkSolutionTE">
<span id="_CPPv3I0EN5riner4Pool14submitSolutionE10unique_ptrI13WorkSolutionTE"></span><span id="_CPPv2I0EN5riner4Pool14submitSolutionE10unique_ptrI13WorkSolutionTE"></span><span class="target" id="classriner_1_1Pool_1a0ab096aab54d372b668abc1c1b0663b7"></span>template&lt;class <code class="sig-name descname">WorkSolutionT</code>&gt;<br />void <code class="sig-name descname">submitSolution</code><span class="sig-paren">(</span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4I0EN5riner4Pool14submitSolutionEv10unique_ptrI13WorkSolutionTE" title="riner::Pool::submitSolution::WorkSolutionT">WorkSolutionT</a>&gt; <em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5riner4Pool14submitSolutionEv10unique_ptrI13WorkSolutionTE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>submit a found solution to the pool this method is supposed to be called from within an AlgoImpl. It is the intended way of submitting solutions. this method takes the ownership of the given solution and starts its async submission, so that this method can return quickly without blocking. AlgoImpls usually check the validity of a Solution before submitting through this call </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solution</span></code>: the solution to be submitted to the pool </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4Pool8isActiveEv">
<span id="_CPPv3NK5riner4Pool8isActiveEv"></span><span id="_CPPv2NK5riner4Pool8isActiveEv"></span><span id="riner::Pool::isActiveC"></span><span class="target" id="classriner_1_1Pool_1a0fb4d19c7d1c555f40ac64e6b4e4efeb"></span>bool <code class="sig-name descname">isActive</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Pool8isActiveEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the pool shall try to establish a connection </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4Pool11isConnectedEv">
<span id="_CPPv3NK5riner4Pool11isConnectedEv"></span><span id="_CPPv2NK5riner4Pool11isConnectedEv"></span><span id="riner::Pool::isConnectedC"></span><span class="target" id="classriner_1_1Pool_1abe5541bbb0a23b0926e0f38dc1a9c676"></span>bool <code class="sig-name descname">isConnected</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Pool11isConnectedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether a connection is established and whether it received a job yet </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4Pool10isDisabledEv">
<span id="_CPPv3NK5riner4Pool10isDisabledEv"></span><span id="_CPPv2NK5riner4Pool10isDisabledEv"></span><span id="riner::Pool::isDisabledC"></span><span class="target" id="classriner_1_1Pool_1ae5e0152a6dc1b7fa95009dd58827e5b4"></span>bool <code class="sig-name descname">isDisabled</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Pool10isDisabledEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the pool is disabled, e.g. because of wrong pool credentials </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4Pool15getPoolImplNameEv">
<span id="_CPPv3NK5riner4Pool15getPoolImplNameEv"></span><span id="_CPPv2NK5riner4Pool15getPoolImplNameEv"></span><span id="riner::Pool::getPoolImplNameC"></span><span class="target" id="classriner_1_1Pool_1a3e481e79636138a66218d8be0d77a0d1"></span>std::string <code class="sig-name descname">getPoolImplName</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Pool15getPoolImplNameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>string name of the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclass (aka PoolImpl) as it can be passed to makePool </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4Pool10getPowTypeEv">
<span id="_CPPv3NK5riner4Pool10getPowTypeEv"></span><span id="_CPPv2NK5riner4Pool10getPowTypeEv"></span><span id="riner::Pool::getPowTypeC"></span><span class="target" id="classriner_1_1Pool_1afb5f542903cf09d241e7248e1f2f60b8"></span>std::string <code class="sig-name descname">getPowType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4Pool10getPowTypeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the POWtype that this <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> implements (e.g. in order to connect it with a fitting AlgoImpl, or group it with Pools that support the same POWtype in a <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a>) <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>this pool’s supported POWtype as a string </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner4Pool8postInitENSt10shared_ptrI4PoolEERKNSt6stringERKNSt6stringE">
<span id="_CPPv3N5riner4Pool8postInitENSt10shared_ptrI4PoolEERKNSt6stringERKNSt6stringE"></span><span id="_CPPv2N5riner4Pool8postInitENSt10shared_ptrI4PoolEERKNSt6stringERKNSt6stringE"></span><span id="riner::Pool::postInit__std::shared_ptr:Pool:.ssCR.ssCR"></span><span class="target" id="classriner_1_1Pool_1acfadc2346e762a35ead4d9ebe32d9381"></span>void <code class="sig-name descname">postInit</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4PoolE" title="riner::Pool">Pool</a>&gt; <em>w</em>, <em class="property">const</em> std::string &amp;<em>poolImplName</em>, <em class="property">const</em> std::string &amp;<em>powType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4Pool8postInitENSt10shared_ptrI4PoolEERKNSt6stringERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>inits private/protected base class members without requiring the user to pass them through. called by the poolswitcher during initialization <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code>: a shared pointer owning *this, which gets stored in this-&gt;_this </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">poolImplName</span></code>: the implementation name according to <a class="reference internal" href="#classriner_1_1Registry"><span class="std std-ref">Registry</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">powType</span></code>: the powtype string according to <a class="reference internal" href="#classriner_1_1Registry"><span class="std std-ref">Registry</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4Pool11generateUidEv">
<span id="_CPPv3N5riner4Pool11generateUidEv"></span><span id="_CPPv2N5riner4Pool11generateUidEv"></span><span id="riner::Pool::generateUid"></span><span class="target" id="classriner_1_1Pool_1a781e2b5064dfee9d1ea8ce3fa7d797e9"></span>uint64_t <code class="sig-name descname">generateUid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4Pool11generateUidEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>simple uid creation function for pools (thread safe) </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="workqueue">
<h2>WorkQueue<a class="headerlink" href="#workqueue" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9WorkQueueE">
<span id="_CPPv3N5riner9WorkQueueE"></span><span id="_CPPv2N5riner9WorkQueueE"></span><span id="riner::WorkQueue"></span><span class="target" id="classriner_1_1WorkQueue"></span><em class="property">class </em><code class="sig-name descname">WorkQueue</code><a class="headerlink" href="#_CPPv4N5riner9WorkQueueE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>provides an implementation of a queue with <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> instances, which is able to generate <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> This queue returns work from a work queue, which is filled asyncronously by a batch operation. Use this queue if the implemenation of <a class="reference internal" href="#structriner_1_1PoolJob_1a19c0464f89fe0d8eaf36f7d6f49d600b"><span class="std std-ref">PoolJob::makeWork()</span></a> is complex, i.e. when it performs cryptographic hash calculations or when it could block. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner9WorkQueue14popWithTimeoutENSt6chrono12steady_clock8durationE">
<span id="_CPPv3N5riner9WorkQueue14popWithTimeoutENSt6chrono12steady_clock8durationE"></span><span id="_CPPv2N5riner9WorkQueue14popWithTimeoutENSt6chrono12steady_clock8durationE"></span><span id="riner::WorkQueue::popWithTimeout__std::chrono::steady_clock::duration"></span><span class="target" id="classriner_1_1WorkQueue_1ae8585b8daa86222c9955fef656600950"></span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">popWithTimeout</code><span class="sig-paren">(</span>std::chrono::steady_clock::duration <em>timeoutDuration</em> = std::chrono::milliseconds(100)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9WorkQueue14popWithTimeoutENSt6chrono12steady_clock8durationE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>pops a <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> object from the queue, if no work object is available, it will wait for timeoutDuration and returns work if it becomes available in that timeframe. returns nullptr after timeout. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a work object created by jobs in the jobQueue via job-&gt;makeWork() or nullptr if timeout happened </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">timeoutDuration</span></code>: time to wait for new work to arrive </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner9WorkQueue12isExpiredJobERK7PoolJob">
<span id="_CPPv3N5riner9WorkQueue12isExpiredJobERK7PoolJob"></span><span id="_CPPv2N5riner9WorkQueue12isExpiredJobERK7PoolJob"></span><span id="riner::WorkQueue::isExpiredJob__PoolJobCR"></span><span class="target" id="classriner_1_1WorkQueue_1ab5e87298dc5d553bb80b0626a0c2f95e"></span>bool <code class="sig-name descname">isExpiredJob</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a> &amp;<em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9WorkQueue12isExpiredJobERK7PoolJob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the job is the latest job in the jobQueue </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner9WorkQueue5clearEv">
<span id="_CPPv3N5riner9WorkQueue5clearEv"></span><span id="_CPPv2N5riner9WorkQueue5clearEv"></span><span id="riner::WorkQueue::clear"></span><span class="target" id="classriner_1_1WorkQueue_1a0a1b4535060c2ad0408bb26db82d2ad4"></span>void <code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9WorkQueue5clearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clears the job queue </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner9WorkQueue10expireJobsEv">
<span id="_CPPv3N5riner9WorkQueue10expireJobsEv"></span><span id="_CPPv2N5riner9WorkQueue10expireJobsEv"></span><span id="riner::WorkQueue::expireJobs"></span><span class="target" id="classriner_1_1WorkQueue_1a5a6a1d81e54074b835b2f1b3b5935b2a"></span>void <code class="sig-name descname">expireJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9WorkQueue10expireJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increases the latestJobId counter, so that all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> from this queue is marked as expired </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="lazyworkqueue">
<h2>LazyWorkQueue<a class="headerlink" href="#lazyworkqueue" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner13LazyWorkQueueE">
<span id="_CPPv3N5riner13LazyWorkQueueE"></span><span id="_CPPv2N5riner13LazyWorkQueueE"></span><span id="riner::LazyWorkQueue"></span><span class="target" id="classriner_1_1LazyWorkQueue"></span><em class="property">class </em><code class="sig-name descname">LazyWorkQueue</code><a class="headerlink" href="#_CPPv4N5riner13LazyWorkQueueE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>provides an implementation of a queue with <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> instances, which is able to generate <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> This queue blocks while <a class="reference internal" href="#structriner_1_1PoolJob_1a19c0464f89fe0d8eaf36f7d6f49d600b"><span class="std std-ref">PoolJob::makeWork()</span></a> is called. Therefore its usage is anticipated if makeWork() returns quickly, i.e. when it increments a counter only. Do not use this implementations if makeWork() includes a hash calculation or if it could block! </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner13LazyWorkQueue5clearEv">
<span id="_CPPv3N5riner13LazyWorkQueue5clearEv"></span><span id="_CPPv2N5riner13LazyWorkQueue5clearEv"></span><span id="riner::LazyWorkQueue::clear"></span><span class="target" id="classriner_1_1LazyWorkQueue_1a63b3dbb645919338cb04dc6a64c9a6e0"></span>void <code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13LazyWorkQueue5clearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clears the job queue </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13LazyWorkQueue10expireJobsEv">
<span id="_CPPv3N5riner13LazyWorkQueue10expireJobsEv"></span><span id="_CPPv2N5riner13LazyWorkQueue10expireJobsEv"></span><span id="riner::LazyWorkQueue::expireJobs"></span><span class="target" id="classriner_1_1LazyWorkQueue_1ab136f47f9a62a8b797f14b1eb8035bb2"></span>void <code class="sig-name descname">expireJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13LazyWorkQueue10expireJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increases the latestJobId counter, so that all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> from this queue is marked as expired </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="poolethashstratum">
<h2>PoolEthashStratum<a class="headerlink" href="#poolethashstratum" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner17PoolEthashStratumE">
<span id="_CPPv3N5riner17PoolEthashStratumE"></span><span id="_CPPv2N5riner17PoolEthashStratumE"></span><span id="riner::PoolEthashStratum"></span><span class="target" id="classriner_1_1PoolEthashStratum"></span><em class="property">class </em><code class="sig-name descname">PoolEthashStratum</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner4PoolE" title="riner::Pool">Pool</a><a class="headerlink" href="#_CPPv4N5riner17PoolEthashStratumE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>PoolImpl for ethash, see “Registry.cpp” </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner17PoolEthashStratum10expireJobsEv">
<span id="_CPPv3N5riner17PoolEthashStratum10expireJobsEv"></span><span id="_CPPv2N5riner17PoolEthashStratum10expireJobsEv"></span><span id="riner::PoolEthashStratum::expireJobs"></span><span class="target" id="classriner_1_1PoolEthashStratum_1a71ee45f6328defbe12e2c2ab9fa258cf"></span>void <code class="sig-name descname">expireJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner17PoolEthashStratum10expireJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>on pool switch this method is called by the <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a>, so that all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> from this pool is marked as expired and the GPUs request new work after this </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner17PoolEthashStratum9clearJobsEv">
<span id="_CPPv3N5riner17PoolEthashStratum9clearJobsEv"></span><span id="_CPPv2N5riner17PoolEthashStratum9clearJobsEv"></span><span id="riner::PoolEthashStratum::clearJobs"></span><span class="target" id="classriner_1_1PoolEthashStratum_1a5d41c29375162d93b9bc6eb30bc9c413"></span>void <code class="sig-name descname">clearJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner17PoolEthashStratum9clearJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clears the job queue and therefore all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> and <a class="reference internal" href="#classriner_1_1WorkSolution"><span class="std std-ref">WorkSolution</span></a> from this pool is invalidated. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner17PoolEthashStratum14onDeclaredDeadEv">
<span id="_CPPv3N5riner17PoolEthashStratum14onDeclaredDeadEv"></span><span id="_CPPv2N5riner17PoolEthashStratum14onDeclaredDeadEv"></span><span id="riner::PoolEthashStratum::onDeclaredDead"></span><span class="target" id="classriner_1_1PoolEthashStratum_1a2a469e5a46134d84ca84ee88dd16f97f"></span>void <code class="sig-name descname">onDeclaredDead</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner17PoolEthashStratum14onDeclaredDeadEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The pool switcher will declare pools dead if they didn’t respond for a certain amount of time. PoolImpls are supposed to call <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1StillAliveTrackable_1ab076ce95ca19d172692f47270c7da854"><span class="std std-ref"><span class="pre">StillAliveTrackable::onStillAlive</span></span></a></code> every time they receive a message from the pool. The <a class="reference internal" href="#classriner_1_1StillAliveTrackable"><span class="std std-ref">StillAliveTrackable</span></a> interface is used to figure out whether to declare a pool dead. Once it is declared dead the PoolImpl can react by overloading this function and trying to disconnect and reconnect to the pool. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner17PoolEthashStratum12isExpiredJobERK7PoolJob">
<span id="_CPPv3N5riner17PoolEthashStratum12isExpiredJobERK7PoolJob"></span><span id="_CPPv2N5riner17PoolEthashStratum12isExpiredJobERK7PoolJob"></span><span id="riner::PoolEthashStratum::isExpiredJob__PoolJobCR"></span><span class="target" id="classriner_1_1PoolEthashStratum_1ad759ec08d7cdebe98fb3bd119d4a443c"></span>bool <code class="sig-name descname">isExpiredJob</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a> &amp;<em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner17PoolEthashStratum12isExpiredJobERK7PoolJob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the pool job is considered expired. Most implementations forward this call to the <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a>’s <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1WorkQueue_1ab5e87298dc5d553bb80b0626a0c2f95e"><span class="std std-ref"><span class="pre">WorkQueue::isExpiredJob()</span></span></a></code> method, which returns false as soon as a newer job was pushed. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner17PoolEthashStratum14tryGetWorkImplEv">
<span id="_CPPv3N5riner17PoolEthashStratum14tryGetWorkImplEv"></span><span id="_CPPv2N5riner17PoolEthashStratum14tryGetWorkImplEv"></span><span id="riner::PoolEthashStratum::tryGetWorkImpl"></span><span class="target" id="classriner_1_1PoolEthashStratum_1a0e6a2834ba79254e707966d79415db7e"></span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">tryGetWorkImpl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner17PoolEthashStratum14tryGetWorkImplEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tryGetWorkImpl call as implemented by the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclasses (aka PoolImpls) </p>
<p>this method is only supposed to be called by the templated <a class="reference internal" href="#classriner_1_1Pool_1a659d022caf0ef6d2adb140ce06415a4f"><span class="std std-ref">tryGetWork&lt;WorkT&gt;()</span></a> method below. this method tries to return valid work as quickly as possible, but also blocks for a short amount of time to wait for work to become available if it isn’t already when the call is being made. After a short timeout period with still no work available, nullptr is returned. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type erased valid unique_ptr or nullptr </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner17PoolEthashStratum18submitSolutionImplE10unique_ptrI12WorkSolutionE">
<span id="_CPPv3N5riner17PoolEthashStratum18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="_CPPv2N5riner17PoolEthashStratum18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="riner::PoolEthashStratum::submitSolutionImpl__unique_ptr:WorkSolution:"></span><span class="target" id="classriner_1_1PoolEthashStratum_1a6ddae1add2a26564ec299eab617c9989"></span>void <code class="sig-name descname">submitSolutionImpl</code><span class="sig-paren">(</span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner12WorkSolutionE" title="riner::WorkSolution">WorkSolution</a>&gt; <em>solution</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner17PoolEthashStratum18submitSolutionImplE10unique_ptrI12WorkSolutionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>submitSolutionImpl call as implemented by the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclasses (aka PoolImpls) </p>
<p>this method is only supposed to be called by the templated <a class="reference internal" href="#classriner_1_1Pool_1a0ab096aab54d372b668abc1c1b0663b7"><span class="std std-ref">submitSolution&lt;WorkSolutionT&gt;()</span></a> method below. this method takes the ownership of the given solution and starts its async submission, so that this method can return quickly without blocking. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solution</span></code>: the solution to be submitted to the pool </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="poolgrinstratum">
<h2>PoolGrinStratum<a class="headerlink" href="#poolgrinstratum" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner15PoolGrinStratumE">
<span id="_CPPv3N5riner15PoolGrinStratumE"></span><span id="_CPPv2N5riner15PoolGrinStratumE"></span><span id="riner::PoolGrinStratum"></span><span class="target" id="classriner_1_1PoolGrinStratum"></span><em class="property">class </em><code class="sig-name descname">PoolGrinStratum</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner4PoolE" title="riner::Pool">Pool</a><a class="headerlink" href="#_CPPv4N5riner15PoolGrinStratumE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner15PoolGrinStratum10expireJobsEv">
<span id="_CPPv3N5riner15PoolGrinStratum10expireJobsEv"></span><span id="_CPPv2N5riner15PoolGrinStratum10expireJobsEv"></span><span id="riner::PoolGrinStratum::expireJobs"></span><span class="target" id="classriner_1_1PoolGrinStratum_1a9ee7132ef0ad436f60db8dd75bd8ef57"></span>void <code class="sig-name descname">expireJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15PoolGrinStratum10expireJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>on pool switch this method is called by the <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a>, so that all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> from this pool is marked as expired and the GPUs request new work after this </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner15PoolGrinStratum9clearJobsEv">
<span id="_CPPv3N5riner15PoolGrinStratum9clearJobsEv"></span><span id="_CPPv2N5riner15PoolGrinStratum9clearJobsEv"></span><span id="riner::PoolGrinStratum::clearJobs"></span><span class="target" id="classriner_1_1PoolGrinStratum_1a9bbb028ab35ab0b2d29f42839cd17fd0"></span>void <code class="sig-name descname">clearJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15PoolGrinStratum9clearJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clears the job queue and therefore all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> and <a class="reference internal" href="#classriner_1_1WorkSolution"><span class="std std-ref">WorkSolution</span></a> from this pool is invalidated. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner15PoolGrinStratum12isExpiredJobERK7PoolJob">
<span id="_CPPv3N5riner15PoolGrinStratum12isExpiredJobERK7PoolJob"></span><span id="_CPPv2N5riner15PoolGrinStratum12isExpiredJobERK7PoolJob"></span><span id="riner::PoolGrinStratum::isExpiredJob__PoolJobCR"></span><span class="target" id="classriner_1_1PoolGrinStratum_1ae97df04d01a5277049eedd704c09f6fa"></span>bool <code class="sig-name descname">isExpiredJob</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a> &amp;<em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15PoolGrinStratum12isExpiredJobERK7PoolJob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the pool job is considered expired. Most implementations forward this call to the <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a>’s <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1WorkQueue_1ab5e87298dc5d553bb80b0626a0c2f95e"><span class="std std-ref"><span class="pre">WorkQueue::isExpiredJob()</span></span></a></code> method, which returns false as soon as a newer job was pushed. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner15PoolGrinStratum14tryGetWorkImplEv">
<span id="_CPPv3N5riner15PoolGrinStratum14tryGetWorkImplEv"></span><span id="_CPPv2N5riner15PoolGrinStratum14tryGetWorkImplEv"></span><span id="riner::PoolGrinStratum::tryGetWorkImpl"></span><span class="target" id="classriner_1_1PoolGrinStratum_1ac257e173e85be34fd975cbed55f0bdd5"></span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">tryGetWorkImpl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15PoolGrinStratum14tryGetWorkImplEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tryGetWorkImpl call as implemented by the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclasses (aka PoolImpls) </p>
<p>this method is only supposed to be called by the templated <a class="reference internal" href="#classriner_1_1Pool_1a659d022caf0ef6d2adb140ce06415a4f"><span class="std std-ref">tryGetWork&lt;WorkT&gt;()</span></a> method below. this method tries to return valid work as quickly as possible, but also blocks for a short amount of time to wait for work to become available if it isn’t already when the call is being made. After a short timeout period with still no work available, nullptr is returned. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type erased valid unique_ptr or nullptr </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner15PoolGrinStratum18submitSolutionImplE10unique_ptrI12WorkSolutionE">
<span id="_CPPv3N5riner15PoolGrinStratum18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="_CPPv2N5riner15PoolGrinStratum18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="riner::PoolGrinStratum::submitSolutionImpl__unique_ptr:WorkSolution:"></span><span class="target" id="classriner_1_1PoolGrinStratum_1a09577d78fe2dfa6561d4ac789935891f"></span>void <code class="sig-name descname">submitSolutionImpl</code><span class="sig-paren">(</span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner12WorkSolutionE" title="riner::WorkSolution">WorkSolution</a>&gt; <em>solution</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15PoolGrinStratum18submitSolutionImplE10unique_ptrI12WorkSolutionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>submitSolutionImpl call as implemented by the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclasses (aka PoolImpls) </p>
<p>this method is only supposed to be called by the templated <a class="reference internal" href="#classriner_1_1Pool_1a0ab096aab54d372b668abc1c1b0663b7"><span class="std std-ref">submitSolution&lt;WorkSolutionT&gt;()</span></a> method below. this method takes the ownership of the given solution and starts its async submission, so that this method can return quickly without blocking. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solution</span></code>: the solution to be submitted to the pool </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner15PoolGrinStratum14onDeclaredDeadEv">
<span id="_CPPv3N5riner15PoolGrinStratum14onDeclaredDeadEv"></span><span id="_CPPv2N5riner15PoolGrinStratum14onDeclaredDeadEv"></span><span id="riner::PoolGrinStratum::onDeclaredDead"></span><span class="target" id="classriner_1_1PoolGrinStratum_1aff1c2258bdf9d7a7eea491778b5dc809"></span>void <code class="sig-name descname">onDeclaredDead</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner15PoolGrinStratum14onDeclaredDeadEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The pool switcher will declare pools dead if they didn’t respond for a certain amount of time. PoolImpls are supposed to call <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1StillAliveTrackable_1ab076ce95ca19d172692f47270c7da854"><span class="std std-ref"><span class="pre">StillAliveTrackable::onStillAlive</span></span></a></code> every time they receive a message from the pool. The <a class="reference internal" href="#classriner_1_1StillAliveTrackable"><span class="std std-ref">StillAliveTrackable</span></a> interface is used to figure out whether to declare a pool dead. Once it is declared dead the PoolImpl can react by overloading this function and trying to disconnect and reconnect to the pool. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="poolswitcher">
<h2>PoolSwitcher<a class="headerlink" href="#poolswitcher" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner12PoolSwitcherE">
<span id="_CPPv3N5riner12PoolSwitcherE"></span><span id="_CPPv2N5riner12PoolSwitcherE"></span><span id="riner::PoolSwitcher"></span><span class="target" id="classriner_1_1PoolSwitcher"></span><em class="property">class </em><code class="sig-name descname">PoolSwitcher</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner4PoolE" title="riner::Pool">Pool</a><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcherE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>maintains connections to multiple Pools as written down in the Config in descending priority order. <code class="docutils literal notranslate"><span class="pre">tryGetWork</span></code> always fetches work from the highest priority <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> that does not have a dead connection. A connection is considered dead if the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> (which extends <a class="reference internal" href="#classriner_1_1StillAliveTrackable"><span class="std std-ref">StillAliveTrackable</span></a>) did not call its <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1StillAliveTrackable_1ab076ce95ca19d172692f47270c7da854"><span class="std std-ref"><span class="pre">onStillAlive()</span></span></a></code> for <code class="docutils literal notranslate"><span class="pre">PoolSwitcher::durUntilDeclaredDead</span></code> seconds This condition is being checked regularly on a separate thread every ‘checkInterval’ seconds by this class </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher12PoolSwitcherENSt6stringEN5clock8durationEN5clock8durationE">
<span id="_CPPv3N5riner12PoolSwitcher12PoolSwitcherENSt6stringEN5clock8durationEN5clock8durationE"></span><span id="_CPPv2N5riner12PoolSwitcher12PoolSwitcherENSt6stringEN5clock8durationEN5clock8durationE"></span><span id="riner::PoolSwitcher::PoolSwitcher__ss.clock::duration.clock::duration"></span><span class="target" id="classriner_1_1PoolSwitcher_1a481d0d1edcdf7aed042fa0cee9cb587f"></span><code class="sig-name descname">PoolSwitcher</code><span class="sig-paren">(</span>std::string <em>powType</em>, clock::duration <em>checkInterval</em> = std::chrono::seconds(20), clock::duration <em>durUntilDeclaredDead</em> = std::chrono::seconds(60)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher12PoolSwitcherENSt6stringEN5clock8durationEN5clock8durationE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates a <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a> for a given PowType <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">powType</span></code>: the PowType of all pools that will ever be added to this pool switcher </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">checkInterval</span></code>: the interval in which the alive status (see <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1StillAliveTrackable"><span class="std std-ref"><span class="pre">StillAliveTrackable</span></span></a></code>) of pools is checked </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">durUntilDeclaredDead</span></code>: if the checking thread notices that the last life sign of a pool was longer ago than this duration, the pool will be declared dead, and the next alive pool will be chosen as active pool. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher10tryAddPoolERK20PoolConstructionArgsPKcRK8Registry">
<span id="_CPPv3N5riner12PoolSwitcher10tryAddPoolERK20PoolConstructionArgsPKcRK8Registry"></span><span id="_CPPv2N5riner12PoolSwitcher10tryAddPoolERK20PoolConstructionArgsPKcRK8Registry"></span><span id="riner::PoolSwitcher::tryAddPool__PoolConstructionArgsCR.cCP.RegistryCR"></span><span class="target" id="classriner_1_1PoolSwitcher_1a2a648353e96cd36db42d878ff43e681c"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4PoolE" title="riner::Pool">Pool</a>&gt; <code class="sig-name descname">tryAddPool</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner20PoolConstructionArgsE" title="riner::PoolConstructionArgs">PoolConstructionArgs</a> &amp;<em>args</em>, <em class="property">const</em> char *<em>poolImplName</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner8RegistryE" title="riner::Registry">Registry</a> &amp;<em>registry</em> = <a class="reference internal" href="#_CPPv4N5riner8RegistryE" title="riner::Registry">Registry</a>{}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher10tryAddPoolERK20PoolConstructionArgsPKcRK8Registry" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tries to construct a pool (may fail if the poolImplName doesn’t exist in <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1Registry"><span class="std std-ref"><span class="pre">Registry</span></span></a></code>) the new pool’s <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1PoolRecords"><span class="std std-ref"><span class="pre">PoolRecords</span></span></a></code> will get connected to the total records of this <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher14tryGetWorkImplEv">
<span id="_CPPv3N5riner12PoolSwitcher14tryGetWorkImplEv"></span><span id="_CPPv2N5riner12PoolSwitcher14tryGetWorkImplEv"></span><span id="riner::PoolSwitcher::tryGetWorkImpl"></span><span class="target" id="classriner_1_1PoolSwitcher_1a0bc966a8d379c91ddce8ae1df4a5ac59"></span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">tryGetWorkImpl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher14tryGetWorkImplEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>redirects the tryGetWork call to the active pool. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>nullptr if either the active pool does not have work, or there is no active pool. Valid work otherwise, which can be downcast to the specific work type (e.g. <a class="reference internal" href="#classriner_1_1WorkEthash"><span class="std std-ref">WorkEthash</span></a> for powType “ethash”) </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher18submitSolutionImplE10unique_ptrI12WorkSolutionE">
<span id="_CPPv3N5riner12PoolSwitcher18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="_CPPv2N5riner12PoolSwitcher18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="riner::PoolSwitcher::submitSolutionImpl__unique_ptr:WorkSolution:"></span><span class="target" id="classriner_1_1PoolSwitcher_1a36760cfd0502f78e912f57cfcbfae39e"></span>void <code class="sig-name descname">submitSolutionImpl</code><span class="sig-paren">(</span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner12WorkSolutionE" title="riner::WorkSolution">WorkSolution</a>&gt; <em>solution</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher18submitSolutionImplE10unique_ptrI12WorkSolutionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>redirects the submitSolution call to the active pool. See implementation for more details </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher14onDeclaredDeadEv">
<span id="_CPPv3N5riner12PoolSwitcher14onDeclaredDeadEv"></span><span id="_CPPv2N5riner12PoolSwitcher14onDeclaredDeadEv"></span><span id="riner::PoolSwitcher::onDeclaredDead"></span><span class="target" id="classriner_1_1PoolSwitcher_1a47f827d535dbe3d0a8837ed841855b39"></span>void <code class="sig-name descname">onDeclaredDead</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher14onDeclaredDeadEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>obsolete poolswitcher should be no longer subclass of <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher12isExpiredJobERK7PoolJob">
<span id="_CPPv3N5riner12PoolSwitcher12isExpiredJobERK7PoolJob"></span><span id="_CPPv2N5riner12PoolSwitcher12isExpiredJobERK7PoolJob"></span><span id="riner::PoolSwitcher::isExpiredJob__PoolJobCR"></span><span class="target" id="classriner_1_1PoolSwitcher_1ab6f437eed96d7d172179384d1d7e33da"></span>bool <code class="sig-name descname">isExpiredJob</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a> &amp;<em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher12isExpiredJobERK7PoolJob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the pool job is considered expired. Most implementations forward this call to the <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a>’s <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1WorkQueue_1ab5e87298dc5d553bb80b0626a0c2f95e"><span class="std std-ref"><span class="pre">WorkQueue::isExpiredJob()</span></span></a></code> method, which returns false as soon as a newer job was pushed. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher10expireJobsEv">
<span id="_CPPv3N5riner12PoolSwitcher10expireJobsEv"></span><span id="_CPPv2N5riner12PoolSwitcher10expireJobsEv"></span><span id="riner::PoolSwitcher::expireJobs"></span><span class="target" id="classriner_1_1PoolSwitcher_1afad41ddb68a0ef95855677f1c0a91507"></span>void <code class="sig-name descname">expireJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher10expireJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>on pool switch this method is called by the <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a>, so that all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> from this pool is marked as expired and the GPUs request new work after this </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher9clearJobsEv">
<span id="_CPPv3N5riner12PoolSwitcher9clearJobsEv"></span><span id="_CPPv2N5riner12PoolSwitcher9clearJobsEv"></span><span id="riner::PoolSwitcher::clearJobs"></span><span class="target" id="classriner_1_1PoolSwitcher_1af06708afc0b241a1f3994c57b3e2923f"></span>void <code class="sig-name descname">clearJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher9clearJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clears the job queue and therefore all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> and <a class="reference internal" href="#classriner_1_1WorkSolution"><span class="std std-ref">WorkSolution</span></a> from this pool is invalidated. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner12PoolSwitcher9poolCountEv">
<span id="_CPPv3NK5riner12PoolSwitcher9poolCountEv"></span><span id="_CPPv2NK5riner12PoolSwitcher9poolCountEv"></span><span id="riner::PoolSwitcher::poolCountC"></span><span class="target" id="classriner_1_1PoolSwitcher_1a3abd5d182c39b15565fe62108148a890"></span>size_t <code class="sig-name descname">poolCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner12PoolSwitcher9poolCountEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>amount of pools added to this pool switcher </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner12PoolSwitcher12getPoolsDataEv">
<span id="_CPPv3NK5riner12PoolSwitcher12getPoolsDataEv"></span><span id="_CPPv2NK5riner12PoolSwitcher12getPoolsDataEv"></span><span id="riner::PoolSwitcher::getPoolsDataC"></span><span class="target" id="classriner_1_1PoolSwitcher_1afa0dad1a7b9fb920a635656b2a3f6100"></span>std::vector&lt;std::shared_ptr&lt;<em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner4PoolE" title="riner::Pool">Pool</a>&gt;&gt; <code class="sig-name descname">getPoolsData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner12PoolSwitcher12getPoolsDataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>const references to the pools with shared ownership. useful for introspection of pool data (e.g. by <a class="reference internal" href="#classriner_1_1ApiServer"><span class="std std-ref">ApiServer</span></a>) </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher19notifyOnPoolsChangeEv">
<span id="_CPPv3N5riner12PoolSwitcher19notifyOnPoolsChangeEv"></span><span id="_CPPv2N5riner12PoolSwitcher19notifyOnPoolsChangeEv"></span><span id="riner::PoolSwitcher::notifyOnPoolsChange"></span><span class="target" id="classriner_1_1PoolSwitcher_1aea1d6a5065d2d820460f4782adc3a2af"></span>void <code class="sig-name descname">notifyOnPoolsChange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher19notifyOnPoolsChangeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>after changes of _pools this method shall be called, so that the <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a> can check pools immediately </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner12PoolSwitcher24aliveCheckAndMaybeSwitchE6size_t">
<span id="_CPPv3N5riner12PoolSwitcher24aliveCheckAndMaybeSwitchE6size_t"></span><span id="_CPPv2N5riner12PoolSwitcher24aliveCheckAndMaybeSwitchE6size_t"></span><span id="riner::PoolSwitcher::aliveCheckAndMaybeSwitch__s"></span><span class="target" id="classriner_1_1PoolSwitcher_1a80151639f9ad1d12d8fcd3150358b33d"></span>size_t <code class="sig-name descname">aliveCheckAndMaybeSwitch</code><span class="sig-paren">(</span>size_t <em>activePoolIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12PoolSwitcher24aliveCheckAndMaybeSwitchE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check which pools are still alive and if the active pool is no longer alive, switch active pool. called by the periodicAliveCheckTask thread </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="pooldummy">
<h2>PoolDummy<a class="headerlink" href="#pooldummy" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9PoolDummyE">
<span id="_CPPv3N5riner9PoolDummyE"></span><span id="_CPPv2N5riner9PoolDummyE"></span><span id="riner::PoolDummy"></span><span class="target" id="classriner_1_1PoolDummy"></span><em class="property">class </em><code class="sig-name descname">PoolDummy</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner4PoolE" title="riner::Pool">Pool</a><a class="headerlink" href="#_CPPv4N5riner9PoolDummyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner9PoolDummy10expireJobsEv">
<span id="_CPPv3N5riner9PoolDummy10expireJobsEv"></span><span id="_CPPv2N5riner9PoolDummy10expireJobsEv"></span><span id="riner::PoolDummy::expireJobs"></span><span class="target" id="classriner_1_1PoolDummy_1a3d96df2145eb3a0595f3d9b3a2e9b440"></span>void <code class="sig-name descname">expireJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9PoolDummy10expireJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>on pool switch this method is called by the <a class="reference internal" href="#classriner_1_1PoolSwitcher"><span class="std std-ref">PoolSwitcher</span></a>, so that all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> from this pool is marked as expired and the GPUs request new work after this </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner9PoolDummy9clearJobsEv">
<span id="_CPPv3N5riner9PoolDummy9clearJobsEv"></span><span id="_CPPv2N5riner9PoolDummy9clearJobsEv"></span><span id="riner::PoolDummy::clearJobs"></span><span class="target" id="classriner_1_1PoolDummy_1ad9b133ca3f367e0e1b78ad69c06979ae"></span>void <code class="sig-name descname">clearJobs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9PoolDummy9clearJobsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clears the job queue and therefore all <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> and <a class="reference internal" href="#classriner_1_1WorkSolution"><span class="std std-ref">WorkSolution</span></a> from this pool is invalidated. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner9PoolDummy12isExpiredJobERK7PoolJob">
<span id="_CPPv3N5riner9PoolDummy12isExpiredJobERK7PoolJob"></span><span id="_CPPv2N5riner9PoolDummy12isExpiredJobERK7PoolJob"></span><span id="riner::PoolDummy::isExpiredJob__PoolJobCR"></span><span class="target" id="classriner_1_1PoolDummy_1aac11fea41e9835014b47162f0a8d14cf"></span>bool <code class="sig-name descname">isExpiredJob</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a> &amp;<em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9PoolDummy12isExpiredJobERK7PoolJob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>whether the pool job is considered expired. Most implementations forward this call to the <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a>’s <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1WorkQueue_1ab5e87298dc5d553bb80b0626a0c2f95e"><span class="std std-ref"><span class="pre">WorkQueue::isExpiredJob()</span></span></a></code> method, which returns false as soon as a newer job was pushed. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner9PoolDummy14tryGetWorkImplEv">
<span id="_CPPv3N5riner9PoolDummy14tryGetWorkImplEv"></span><span id="_CPPv2N5riner9PoolDummy14tryGetWorkImplEv"></span><span id="riner::PoolDummy::tryGetWorkImpl"></span><span class="target" id="classriner_1_1PoolDummy_1a682174c1d8099e8ee54d73e5b43075e8"></span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">tryGetWorkImpl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9PoolDummy14tryGetWorkImplEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tryGetWorkImpl call as implemented by the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclasses (aka PoolImpls) </p>
<p>this method is only supposed to be called by the templated <a class="reference internal" href="#classriner_1_1Pool_1a659d022caf0ef6d2adb140ce06415a4f"><span class="std std-ref">tryGetWork&lt;WorkT&gt;()</span></a> method below. this method tries to return valid work as quickly as possible, but also blocks for a short amount of time to wait for work to become available if it isn’t already when the call is being made. After a short timeout period with still no work available, nullptr is returned. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type erased valid unique_ptr or nullptr </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner9PoolDummy18submitSolutionImplE10unique_ptrI12WorkSolutionE">
<span id="_CPPv3N5riner9PoolDummy18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="_CPPv2N5riner9PoolDummy18submitSolutionImplE10unique_ptrI12WorkSolutionE"></span><span id="riner::PoolDummy::submitSolutionImpl__unique_ptr:WorkSolution:"></span><span class="target" id="classriner_1_1PoolDummy_1af2b2df091509e475977689b27c315f77"></span>void <code class="sig-name descname">submitSolutionImpl</code><span class="sig-paren">(</span>unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner12WorkSolutionE" title="riner::WorkSolution">WorkSolution</a>&gt; <em>solution</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9PoolDummy18submitSolutionImplE10unique_ptrI12WorkSolutionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>submitSolutionImpl call as implemented by the <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclasses (aka PoolImpls) </p>
<p>this method is only supposed to be called by the templated <a class="reference internal" href="#classriner_1_1Pool_1a0ab096aab54d372b668abc1c1b0663b7"><span class="std std-ref">submitSolution&lt;WorkSolutionT&gt;()</span></a> method below. this method takes the ownership of the given solution and starts its async submission, so that this method can return quickly without blocking. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solution</span></code>: the solution to be submitted to the pool </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner9PoolDummy14onDeclaredDeadEv">
<span id="_CPPv3N5riner9PoolDummy14onDeclaredDeadEv"></span><span id="_CPPv2N5riner9PoolDummy14onDeclaredDeadEv"></span><span id="riner::PoolDummy::onDeclaredDead"></span><span class="target" id="classriner_1_1PoolDummy_1aded1ed943a97d1b91e8eb703886fdfca"></span>void <code class="sig-name descname">onDeclaredDead</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner9PoolDummy14onDeclaredDeadEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The pool switcher will declare pools dead if they didn’t respond for a certain amount of time. PoolImpls are supposed to call <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1StillAliveTrackable_1ab076ce95ca19d172692f47270c7da854"><span class="std std-ref"><span class="pre">StillAliveTrackable::onStillAlive</span></span></a></code> every time they receive a message from the pool. The <a class="reference internal" href="#classriner_1_1StillAliveTrackable"><span class="std std-ref">StillAliveTrackable</span></a> interface is used to figure out whether to declare a pool dead. Once it is declared dead the PoolImpl can react by overloading this function and trying to disconnect and reconnect to the pool. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="dummytestpoolserver">
<h2>DummyTestPoolServer<a class="headerlink" href="#dummytestpoolserver" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner19DummyTestPoolServerE">
<span id="_CPPv3N5riner19DummyTestPoolServerE"></span><span id="_CPPv2N5riner19DummyTestPoolServerE"></span><span id="riner::DummyTestPoolServer"></span><span class="target" id="classriner_1_1DummyTestPoolServer"></span><em class="property">class </em><code class="sig-name descname">DummyTestPoolServer</code><a class="headerlink" href="#_CPPv4N5riner19DummyTestPoolServerE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="workcuckoo">
<h2>WorkCuckoo<a class="headerlink" href="#workcuckoo" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I0EN5riner10WorkCuckooE">
<span id="_CPPv3I0EN5riner10WorkCuckooE"></span><span id="_CPPv2I0EN5riner10WorkCuckooE"></span><span class="target" id="classriner_1_1WorkCuckoo"></span>template&lt;class <code class="sig-name descname">PowTypeT</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">WorkCuckoo</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>, <em class="property">public</em> <a class="reference internal" href="#_CPPv4I0EN5riner10WorkCuckooE" title="riner::WorkCuckoo::PowTypeT">PowTypeT</a><a class="headerlink" href="#_CPPv4I0EN5riner10WorkCuckooE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="worksolutioncuckoo">
<h2>WorkSolutionCuckoo<a class="headerlink" href="#worksolutioncuckoo" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I0EN5riner18WorkSolutionCuckooE">
<span id="_CPPv3I0EN5riner18WorkSolutionCuckooE"></span><span id="_CPPv2I0EN5riner18WorkSolutionCuckooE"></span><span class="target" id="classriner_1_1WorkSolutionCuckoo"></span>template&lt;class <code class="sig-name descname">PowTypeT</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">WorkSolutionCuckoo</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner12WorkSolutionE" title="riner::WorkSolution">WorkSolution</a>, <em class="property">public</em> <a class="reference internal" href="#_CPPv4I0EN5riner18WorkSolutionCuckooE" title="riner::WorkSolutionCuckoo::PowTypeT">PowTypeT</a><a class="headerlink" href="#_CPPv4I0EN5riner18WorkSolutionCuckooE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="gpuapiconstructionargs">
<h2>GpuApiConstructionArgs<a class="headerlink" href="#gpuapiconstructionargs" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner22GpuApiConstructionArgsE">
<span id="_CPPv3N5riner22GpuApiConstructionArgsE"></span><span id="_CPPv2N5riner22GpuApiConstructionArgsE"></span><span id="riner::GpuApiConstructionArgs"></span><span class="target" id="structriner_1_1GpuApiConstructionArgs"></span><em class="property">struct </em><code class="sig-name descname">GpuApiConstructionArgs</code><a class="headerlink" href="#_CPPv4N5riner22GpuApiConstructionArgsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This struct represents the constructor args passed into every <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> subclass upon creation see <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1Registry"><span class="std std-ref"><span class="pre">Registry</span></span></a></code> </p>
</dd></dl>

</div>
<div class="section" id="has-value-type">
<h2>has_value_type<a class="headerlink" href="#has-value-type" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4I00EN5riner14has_value_typeE">
<span id="_CPPv3I00EN5riner14has_value_typeE"></span><span id="_CPPv2I00EN5riner14has_value_typeE"></span><span class="target" id="structriner_1_1has__value__type"></span>template&lt;class <code class="sig-name descname">T</code>, class = void&gt;<br /><em class="property">struct </em><code class="sig-name descname">has_value_type</code> : <em class="property">public</em> false_type<a class="headerlink" href="#_CPPv4I00EN5riner14has_value_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>metafunction that returns whether T contains a public T::value_type typedef </p>
</dd></dl>

</div>
<div class="section" id="parsepooladdressresult">
<h2>ParsePoolAddressResult<a class="headerlink" href="#parsepooladdressresult" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner22ParsePoolAddressResultE">
<span id="_CPPv3N5riner22ParsePoolAddressResultE"></span><span id="_CPPv2N5riner22ParsePoolAddressResultE"></span><span id="riner::ParsePoolAddressResult"></span><span class="target" id="structriner_1_1ParsePoolAddressResult"></span><em class="property">struct </em><code class="sig-name descname">ParsePoolAddressResult</code><a class="headerlink" href="#_CPPv4N5riner22ParsePoolAddressResultE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="makestr">
<h2>MakeStr<a class="headerlink" href="#makestr" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner7MakeStrE">
<span id="_CPPv3N5riner7MakeStrE"></span><span id="_CPPv2N5riner7MakeStrE"></span><span id="riner::MakeStr"></span><span class="target" id="structriner_1_1MakeStr"></span><em class="property">struct </em><code class="sig-name descname">MakeStr</code><a class="headerlink" href="#_CPPv4N5riner7MakeStrE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convenience stream-like to create strings in one line usage: <code class="docutils literal notranslate"><span class="pre">(</span><a class="reference internal" href="#structriner_1_1MakeStr"><span class="std std-ref"><span class="pre">MakeStr</span></span></a><span class="pre">{}</span> <span class="pre">&lt;&lt;</span> <span class="pre">&quot;foo&quot;</span> <span class="pre">&lt;&lt;</span> <span class="pre">4.f</span> <span class="pre">&lt;&lt;</span> <span class="pre">&quot;\n&quot;).</span><a class="reference internal" href="#structriner_1_1MakeStr_1a0bc67e4773a0978c59aa5945e2e872d1"><span class="std std-ref"><span class="pre">str()</span></span></a></code> </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4I0ENO5riner7MakeStrlsERR7MakeStrRR1T">
<span id="_CPPv3I0ENO5riner7MakeStrlsERR1T"></span><span id="_CPPv2I0ENO5riner7MakeStrlsERR1T"></span><span class="target" id="structriner_1_1MakeStr_1a267eac154477d325b408893f1dd20e72"></span>template&lt;class <code class="sig-name descname">T</code>&gt;<br /><a class="reference internal" href="#_CPPv4N5riner7MakeStrE" title="riner::MakeStr">MakeStr</a> &amp;&amp;<code class="sig-name descname">operator&lt;&lt;</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0ENO5riner7MakeStrlsERR7MakeStrRR1T" title="riner::MakeStr::operator&lt;&lt;::T">T</a> &amp;&amp;<em>t</em><span class="sig-paren">)</span> &amp;&amp;<a class="headerlink" href="#_CPPv4I0ENO5riner7MakeStrlsERR7MakeStrRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>adds <code class="docutils literal notranslate"><span class="pre">t</span></code> to the result string, see <code class="docutils literal notranslate"><span class="pre">std::stringstream::operator&lt;&lt;</span></code> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner7MakeStr3strEv">
<span id="_CPPv3N5riner7MakeStr3strEv"></span><span id="_CPPv2N5riner7MakeStr3strEv"></span><span id="riner::MakeStr::str"></span><span class="target" id="structriner_1_1MakeStr_1a0bc67e4773a0978c59aa5945e2e872d1"></span>std::string <code class="sig-name descname">str</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner7MakeStr3strEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the result string </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner7MakeStrcvNSt6stringEEv">
<span id="_CPPv3NK5riner7MakeStrcvNSt6stringEEv"></span><span id="_CPPv2NK5riner7MakeStrcvNSt6stringEEv"></span><span id="riner::MakeStr::castto-ss-operatorC"></span><span class="target" id="structriner_1_1MakeStr_1ab0bf3503f6f0341f77a6fc66f6a079ef"></span><code class="sig-name descname">operator std::string</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner7MakeStrcvNSt6stringEEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convenience conversion to obtain the result string </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="setthreadnamestream">
<h2>SetThreadNameStream<a class="headerlink" href="#setthreadnamestream" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner19SetThreadNameStreamE">
<span id="_CPPv3N5riner19SetThreadNameStreamE"></span><span id="_CPPv2N5riner19SetThreadNameStreamE"></span><span id="riner::SetThreadNameStream"></span><span class="target" id="structriner_1_1SetThreadNameStream"></span><em class="property">struct </em><code class="sig-name descname">SetThreadNameStream</code> : <em class="property">public</em> stringstream<a class="headerlink" href="#_CPPv4N5riner19SetThreadNameStreamE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use a stringstream as a convenient setThreadName alternative usage: <a class="reference internal" href="#structriner_1_1SetThreadNameStream"><span class="std std-ref">SetThreadNameStream</span></a>{} &lt;&lt; “MyWorkerThread #” &lt;&lt; number; </p>
</dd></dl>

</div>
<div class="section" id="gpusettings">
<h2>GpuSettings<a class="headerlink" href="#gpusettings" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner11GpuSettingsE">
<span id="_CPPv3N5riner11GpuSettingsE"></span><span id="_CPPv2N5riner11GpuSettingsE"></span><span id="riner::GpuSettings"></span><span class="target" id="structriner_1_1GpuSettings"></span><em class="property">struct </em><code class="sig-name descname">GpuSettings</code><a class="headerlink" href="#_CPPv4N5riner11GpuSettingsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Settings struct that the <a class="reference internal" href="#structriner_1_1Device"><span class="std std-ref">Device</span></a> is populated with according to config info, once a profile is started </p>
</dd></dl>

</div>
<div class="section" id="algosettings">
<h2>AlgoSettings<a class="headerlink" href="#algosettings" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner12AlgoSettingsE">
<span id="_CPPv3N5riner12AlgoSettingsE"></span><span id="_CPPv2N5riner12AlgoSettingsE"></span><span id="riner::AlgoSettings"></span><span class="target" id="structriner_1_1AlgoSettings"></span><em class="property">struct </em><code class="sig-name descname">AlgoSettings</code><a class="headerlink" href="#_CPPv4N5riner12AlgoSettingsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Algorithm settings struct that the <a class="reference internal" href="#structriner_1_1Device"><span class="std std-ref">Device</span></a> is populated with according to device profile info, once a profile is started </p>
</dd></dl>

</div>
<div class="section" id="error">
<h2>Error<a class="headerlink" href="#error" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4jrpc5ErrorE">
<span id="_CPPv3N5riner4jrpc5ErrorE"></span><span id="_CPPv2N5riner4jrpc5ErrorE"></span><span id="riner::jrpc::Error"></span><span class="target" id="structriner_1_1jrpc_1_1Error"></span><em class="property">struct </em><code class="sig-name descname">Error</code> : <em class="property">public</em> exception<a class="headerlink" href="#_CPPv4N5riner4jrpc5ErrorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="response">
<h2>Response<a class="headerlink" href="#response" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4jrpc8ResponseE">
<span id="_CPPv3N5riner4jrpc8ResponseE"></span><span id="_CPPv2N5riner4jrpc8ResponseE"></span><span id="riner::jrpc::Response"></span><span class="target" id="structriner_1_1jrpc_1_1Response"></span><em class="property">struct </em><code class="sig-name descname">Response</code><a class="headerlink" href="#_CPPv4N5riner4jrpc8ResponseE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>response-specific part of <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">jrpc::Message</span></span></a></code>. contains a variant that is either an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Error"><span class="std std-ref"><span class="pre">Error</span></span></a></code> </p>
</dd></dl>

</div>
<div class="section" id="request">
<h2>Request<a class="headerlink" href="#request" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4jrpc7RequestE">
<span id="_CPPv3N5riner4jrpc7RequestE"></span><span id="_CPPv2N5riner4jrpc7RequestE"></span><span id="riner::jrpc::Request"></span><span class="target" id="structriner_1_1jrpc_1_1Request"></span><em class="property">struct </em><code class="sig-name descname">Request</code><a class="headerlink" href="#_CPPv4N5riner4jrpc7RequestE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>request-specific part of <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">jrpc::Message</span></span></a></code>. contains name of the method as well as parameters. (<code class="docutils literal notranslate"><span class="pre">params</span></code> is <code class="docutils literal notranslate"><span class="pre">nl::json{}</span></code> if the method takes no parameters) </p>
</dd></dl>

</div>
<div class="section" id="message">
<h2>Message<a class="headerlink" href="#message" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner4jrpc7MessageE">
<span id="_CPPv3N5riner4jrpc7MessageE"></span><span id="_CPPv2N5riner4jrpc7MessageE"></span><span id="riner::jrpc::Message"></span><span class="target" id="structriner_1_1jrpc_1_1Message"></span><em class="property">struct </em><code class="sig-name descname">Message</code><a class="headerlink" href="#_CPPv4N5riner4jrpc7MessageE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">jrpc::Message</span></span></a></code> class that is used to represent either a jrpc <a class="reference internal" href="#structriner_1_1jrpc_1_1Request"><span class="std std-ref">Request</span></a> or <a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref">Response</span></a> </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner4jrpc7Message7MessageEN2nl4jsonE">
<span id="_CPPv3N5riner4jrpc7Message7MessageEN2nl4jsonE"></span><span id="_CPPv2N5riner4jrpc7Message7MessageEN2nl4jsonE"></span><span id="riner::jrpc::Message::Message__nl::json"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1a7b3c3368ca331a92469d1967a0213863"></span><code class="sig-name descname">Message</code><span class="sig-paren">(</span>nl::json <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc7Message7MessageEN2nl4jsonE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">jrpc::Message</span></span></a></code> by parsing an <code class="docutils literal notranslate"><span class="pre">nl::json</span></code>. Throws the <a class="reference external" href="https://nlohmann.github.io/json/classnlohmann_1_1basic__json_acac9d438c9bb12740dcdb01069293a34.html">exceptions of nlohmann::json::at</a> on parsing failure. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4jrpc7Message7MessageERK8ResponseN2nl4jsonE">
<span id="_CPPv3N5riner4jrpc7Message7MessageERK8ResponseN2nl4jsonE"></span><span id="_CPPv2N5riner4jrpc7Message7MessageERK8ResponseN2nl4jsonE"></span><span id="riner::jrpc::Message::Message__ResponseCR.nl::json"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1a4e6ff3a48baf6881a327e2bb69c4607f"></span><code class="sig-name descname">Message</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner4jrpc8ResponseE" title="riner::jrpc::Response">Response</a> &amp;<em>response</em>, nl::json <em>id</em> = {}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc7Message7MessageERK8ResponseN2nl4jsonE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convenience ctor for creating a response <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">jrpc::Message</span></span></a></code> from a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">jrpc::Response</span></span></a></code> and optionally an <code class="docutils literal notranslate"><span class="pre">id</span></code>. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code>: empty by default, sets the <code class="docutils literal notranslate"><span class="pre">id</span></code> member of the constructed <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">jrpc::Message</span></span></a></code> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4jrpc7Message6toJsonEv">
<span id="_CPPv3NK5riner4jrpc7Message6toJsonEv"></span><span id="_CPPv2NK5riner4jrpc7Message6toJsonEv"></span><span id="riner::jrpc::Message::toJsonC"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1a69b0d7a6723bd18b27ac3982dc015a4c"></span>nl::json <code class="sig-name descname">toJson</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4jrpc7Message6toJsonEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates a <code class="docutils literal notranslate"><span class="pre">nl::json</span></code> that corresponds to this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">jrpc::Message</span></span></a></code> object. Use <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message_1ac731a9ee18c89b841e62320e0eb20db7"><span class="std std-ref"><span class="pre">jrpc::Message::str()</span></span></a></code> instead if you want to directly convert the object to <code class="docutils literal notranslate"><span class="pre">std::string</span></code> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4jrpc7Message14isNotificationEv">
<span id="_CPPv3NK5riner4jrpc7Message14isNotificationEv"></span><span id="_CPPv2NK5riner4jrpc7Message14isNotificationEv"></span><span id="riner::jrpc::Message::isNotificationC"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1ac92e09e96513e5c33e9c8fc4dd86cb05"></span>bool <code class="sig-name descname">isNotification</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4jrpc7Message14isNotificationEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>whether this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a notification, that is, a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">Response</span></span></a></code> with no <code class="docutils literal notranslate"><span class="pre">id</span></code> (<code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">==</span> <span class="pre">nl::json{}</span></code>) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4jrpc7Message9isRequestEv">
<span id="_CPPv3NK5riner4jrpc7Message9isRequestEv"></span><span id="_CPPv2NK5riner4jrpc7Message9isRequestEv"></span><span id="riner::jrpc::Message::isRequestC"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1aea895e47a55a8104af25319bb46b428e"></span>bool <code class="sig-name descname">isRequest</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4jrpc7Message9isRequestEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>whether this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Request"><span class="std std-ref"><span class="pre">Request</span></span></a></code> as opposed to being a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">Response</span></span></a></code> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4jrpc7Message10isResponseEv">
<span id="_CPPv3NK5riner4jrpc7Message10isResponseEv"></span><span id="_CPPv2NK5riner4jrpc7Message10isResponseEv"></span><span id="riner::jrpc::Message::isResponseC"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1ac8eb0cdef40a4b876fba0ce95103c8b7"></span>bool <code class="sig-name descname">isResponse</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4jrpc7Message10isResponseEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>whether this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">Response</span></span></a></code> as opposed to being a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Request"><span class="std std-ref"><span class="pre">Request</span></span></a></code> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4jrpc7Message10getIfErrorEv">
<span id="_CPPv3NK5riner4jrpc7Message10getIfErrorEv"></span><span id="_CPPv2NK5riner4jrpc7Message10getIfErrorEv"></span><span id="riner::jrpc::Message::getIfErrorC"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1aa4736469fd0606cb0919fcf0359e70ed"></span>optional_cref&lt;<a class="reference internal" href="#_CPPv4N5riner4jrpc5ErrorE" title="riner::jrpc::Error">Error</a>&gt; <code class="sig-name descname">getIfError</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4jrpc7Message10getIfErrorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convenience function for quick access to the <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Error"><span class="std std-ref"><span class="pre">jrpc::Error</span></span></a></code>. checks if this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">jrpc::Response</span></span></a></code>, then checks whether it is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Error"><span class="std std-ref"><span class="pre">jrpc::Error</span></span></a></code>. If it is, returns the ref to that <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Error"><span class="std std-ref"><span class="pre">jrpc::Error</span></span></a></code> <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ref to the underlying <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Error"><span class="std std-ref"><span class="pre">jrpc::Error</span></span></a></code> or <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4jrpc7Message11getIfResultEv">
<span id="_CPPv3N5riner4jrpc7Message11getIfResultEv"></span><span id="_CPPv2N5riner4jrpc7Message11getIfResultEv"></span><span id="riner::jrpc::Message::getIfResult"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1aa72bfd77498a108260fa8b118ebf0901"></span>optional_ref&lt;nl::json&gt; <code class="sig-name descname">getIfResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc7Message11getIfResultEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convenience function for quick access to the result <code class="docutils literal notranslate"><span class="pre">nl::json</span></code> object, if this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Request"><span class="std std-ref"><span class="pre">Request</span></span></a></code> that is not an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Error"><span class="std std-ref"><span class="pre">Error</span></span></a></code>. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ref to underlying result <code class="docutils literal notranslate"><span class="pre">nl::json</span></code> object, or <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4jrpc7Message12getIfRequestEv">
<span id="_CPPv3N5riner4jrpc7Message12getIfRequestEv"></span><span id="_CPPv2N5riner4jrpc7Message12getIfRequestEv"></span><span id="riner::jrpc::Message::getIfRequest"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1a0dee915822671e2917a1458ce803f4d2"></span>optional_ref&lt;<a class="reference internal" href="#_CPPv4N5riner4jrpc7RequestE" title="riner::jrpc::Request">Request</a>&gt; <code class="sig-name descname">getIfRequest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc7Message12getIfRequestEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convenience function for quick access to the <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Request"><span class="std std-ref"><span class="pre">Request</span></span></a></code> object. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ref to this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code>’s <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Request"><span class="std std-ref"><span class="pre">jrpc::Request</span></span></a></code> object if it is a request, <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> otherwise. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4I0EN5riner4jrpc7Message8resultAsE8optionalI1TEv">
<span id="_CPPv3I0EN5riner4jrpc7Message8resultAsEv"></span><span id="_CPPv2I0EN5riner4jrpc7Message8resultAsEv"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1a93853c887cc54f04a877c74d2fef7abe"></span>template&lt;class <code class="sig-name descname">T</code>&gt;<br />optional&lt;<a class="reference internal" href="#_CPPv4I0EN5riner4jrpc7Message8resultAsE8optionalI1TEv" title="riner::jrpc::Message::resultAs::T">T</a>&gt; <code class="sig-name descname">resultAs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5riner4jrpc7Message8resultAsE8optionalI1TEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convenience function that checks whether this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">Response</span></span></a></code> that is not an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Error"><span class="std std-ref"><span class="pre">Error</span></span></a></code>. If so, tries to convert the <code class="docutils literal notranslate"><span class="pre">&quot;result&quot;</span></code> object to <code class="docutils literal notranslate"><span class="pre">T</span></code> and return it. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">jrpc::Response</span></span></a></code>s <code class="docutils literal notranslate"><span class="pre">&quot;result&quot;</span></code> as a <code class="docutils literal notranslate"><span class="pre">T</span></code>, or <code class="docutils literal notranslate"><span class="pre">nullopt</span></code> </p>
</dd>
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: the type that the <code class="docutils literal notranslate"><span class="pre">&quot;result&quot;</span></code> should be converted to </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner4jrpc7Message12isResultTrueEv">
<span id="_CPPv3N5riner4jrpc7Message12isResultTrueEv"></span><span id="_CPPv2N5riner4jrpc7Message12isResultTrueEv"></span><span id="riner::jrpc::Message::isResultTrue"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1a5bfbc35b962c2949c0181f5bcde6c69b"></span>bool <code class="sig-name descname">isResultTrue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner4jrpc7Message12isResultTrueEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns whether this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">Response</span></span></a></code> with a <code class="docutils literal notranslate"><span class="pre">&quot;result&quot;</span> <span class="pre">=</span> <span class="pre">True</span></code> entry. this is needed so often that it deserves its own convenience function. This function is safe to be called even if this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is no <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">Response</span></span></a></code> or does not have a <code class="docutils literal notranslate"><span class="pre">&quot;result&quot;</span></code> key. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">Response</span></span></a></code> with a <code class="docutils literal notranslate"><span class="pre">&quot;result&quot;</span> <span class="pre">=</span> <span class="pre">True</span></code> entry, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4jrpc7Message7isErrorEv">
<span id="_CPPv3NK5riner4jrpc7Message7isErrorEv"></span><span id="_CPPv2NK5riner4jrpc7Message7isErrorEv"></span><span id="riner::jrpc::Message::isErrorC"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1acd67375d4cb91ad081d18de65450567f"></span>bool <code class="sig-name descname">isError</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4jrpc7Message7isErrorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns whether this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">Response</span></span></a></code> that is an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Error"><span class="std std-ref"><span class="pre">Error</span></span></a></code> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4jrpc7Message15isErrorWithCodeEN4jrpc9ErrorCodeE">
<span id="_CPPv3NK5riner4jrpc7Message15isErrorWithCodeEN4jrpc9ErrorCodeE"></span><span id="_CPPv2NK5riner4jrpc7Message15isErrorWithCodeEN4jrpc9ErrorCodeE"></span><span id="riner::jrpc::Message::isErrorWithCode__jrpc::ErrorCodeC"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1af5210372ca4061774aca589bd2055265"></span>bool <code class="sig-name descname">isErrorWithCode</code><span class="sig-paren">(</span>jrpc::ErrorCode <em>c</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4jrpc7Message15isErrorWithCodeEN4jrpc9ErrorCodeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns whether this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Response"><span class="std std-ref"><span class="pre">Response</span></span></a></code> that is an <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Error"><span class="std std-ref"><span class="pre">Error</span></span></a></code> with an error code equal to c </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4jrpc7Message13hasMethodNameEPKc">
<span id="_CPPv3NK5riner4jrpc7Message13hasMethodNameEPKc"></span><span id="_CPPv2NK5riner4jrpc7Message13hasMethodNameEPKc"></span><span id="riner::jrpc::Message::hasMethodName__cCPC"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1a3d214a8bd3597faacab263d7e4510d74"></span>bool <code class="sig-name descname">hasMethodName</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4jrpc7Message13hasMethodNameEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns whether this <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a <code class="docutils literal notranslate"><span class="pre">Requeset</span></code> that has the same <code class="docutils literal notranslate"><span class="pre">method</span></code> name as the provided <code class="docutils literal notranslate"><span class="pre">name</span></code> argument. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5riner4jrpc7Message3strEv">
<span id="_CPPv3NK5riner4jrpc7Message3strEv"></span><span id="_CPPv2NK5riner4jrpc7Message3strEv"></span><span id="riner::jrpc::Message::strC"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1ac731a9ee18c89b841e62320e0eb20db7"></span>std::string <code class="sig-name descname">str</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5riner4jrpc7Message3strEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert the <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">jrpc::Message</span></span></a></code> object to a single-line <code class="docutils literal notranslate"><span class="pre">std::string</span></code> ready to be sent. For nicer formatting use <code class="docutils literal notranslate"><span class="pre">nlohmann::json::dump()</span></code> functionality and call <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message_1a69b0d7a6723bd18b27ac3982dc015a4c"><span class="std std-ref"><span class="pre">jrpc::Message::toJson()</span></span></a><span class="pre">.dump(4)</span></code> instead. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p></p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N5riner4jrpc7Message2idE">
<span id="_CPPv3N5riner4jrpc7Message2idE"></span><span id="_CPPv2N5riner4jrpc7Message2idE"></span><span id="riner::jrpc::Message::id__nl::json"></span><span class="target" id="structriner_1_1jrpc_1_1Message_1aec7563c459d8089c55b23846511b7b10"></span>nl::json <code class="sig-name descname">id</code><a class="headerlink" href="#_CPPv4N5riner4jrpc7Message2idE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">id</span></code>, ideally <code class="docutils literal notranslate"><span class="pre">Null</span></code>, <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">Number</span></code> or empty (=<code class="docutils literal notranslate"><span class="pre">nl::json{}</span></code>). Empty means that no <code class="docutils literal notranslate"><span class="pre">id</span></code> member is present altogether and therefore the <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message"><span class="std std-ref"><span class="pre">Message</span></span></a></code> is a notification (see <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1jrpc_1_1Message_1ac92e09e96513e5c33e9c8fc4dd86cb05"><span class="std std-ref"><span class="pre">isNotification()</span></span></a></code>) </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="connection">
<h2>Connection<a class="headerlink" href="#connection" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner10ConnectionE">
<span id="_CPPv3N5riner10ConnectionE"></span><span id="_CPPv2N5riner10ConnectionE"></span><span id="riner::Connection"></span><span class="target" id="structriner_1_1Connection"></span><em class="property">struct </em><code class="sig-name descname">Connection</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner12IOConnectionE" title="riner::IOConnection">IOConnection</a>, <em class="property">public</em> std::enable_shared_from_this&lt;<a class="reference internal" href="#_CPPv4N5riner10ConnectionE" title="riner::Connection">Connection</a>&gt;<a class="headerlink" href="#_CPPv4N5riner10ConnectionE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="ioconversionerror">
<h2>IOConversionError<a class="headerlink" href="#ioconversionerror" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner17IOConversionErrorE">
<span id="_CPPv3N5riner17IOConversionErrorE"></span><span id="_CPPv2N5riner17IOConversionErrorE"></span><span id="riner::IOConversionError"></span><span class="target" id="structriner_1_1IOConversionError"></span><em class="property">struct </em><code class="sig-name descname">IOConversionError</code> : <em class="property">public</em> runtime_error<a class="headerlink" href="#_CPPv4N5riner17IOConversionErrorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An <a class="reference internal" href="#structriner_1_1IOConversionError"><span class="std std-ref">IOConversionError</span></a> should be thrown whenever an <a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref">IOTypeLayer</span></a> implementation fails to convert its argument in either its convertIncoming() or convertOutgoing() method. For more details see std::runtime_error </p>
</dd></dl>

</div>
<div class="section" id="ssldesc">
<h2>SslDesc<a class="headerlink" href="#ssldesc" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner7SslDescE">
<span id="_CPPv3N5riner7SslDescE"></span><span id="_CPPv2N5riner7SslDescE"></span><span id="riner::SslDesc"></span><span class="target" id="structriner_1_1SslDesc"></span><em class="property">struct </em><code class="sig-name descname">SslDesc</code><a class="headerlink" href="#_CPPv4N5riner7SslDescE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This descriptor is used in the <a class="reference internal" href="#classriner_1_1IOTypeLayer"><span class="std std-ref">IOTypeLayer</span></a>’s enableSsl(desc) method. To add further parametrization to the Ssl functionality, enhance this <a class="reference internal" href="#structriner_1_1SslDesc"><span class="std std-ref">SslDesc</span></a> class and use it in Socket.cpp (which contains all the code related to SSL/TLS via asio) </p>
</dd></dl>

</div>
<div class="section" id="algoconstructionargs">
<h2>AlgoConstructionArgs<a class="headerlink" href="#algoconstructionargs" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner20AlgoConstructionArgsE">
<span id="_CPPv3N5riner20AlgoConstructionArgsE"></span><span id="_CPPv2N5riner20AlgoConstructionArgsE"></span><span id="riner::AlgoConstructionArgs"></span><span class="target" id="structriner_1_1AlgoConstructionArgs"></span><em class="property">struct </em><code class="sig-name descname">AlgoConstructionArgs</code><a class="headerlink" href="#_CPPv4N5riner20AlgoConstructionArgsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Args passed into every Algorithm subclass ctor If you want to add args to every algorithm ctor, add them to this struct instead. </p>
</dd></dl>

</div>
<div class="section" id="pcieindex">
<h2>PcieIndex<a class="headerlink" href="#pcieindex" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9PcieIndexE">
<span id="_CPPv3N5riner9PcieIndexE"></span><span id="_CPPv2N5riner9PcieIndexE"></span><span id="riner::PcieIndex"></span><span class="target" id="structriner_1_1PcieIndex"></span><em class="property">struct </em><code class="sig-name descname">PcieIndex</code><a class="headerlink" href="#_CPPv4N5riner9PcieIndexE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="device">
<h2>Device<a class="headerlink" href="#device" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner6DeviceE">
<span id="_CPPv3N5riner6DeviceE"></span><span id="_CPPv2N5riner6DeviceE"></span><span id="riner::Device"></span><span class="target" id="structriner_1_1Device"></span><em class="property">struct </em><code class="sig-name descname">Device</code><a class="headerlink" href="#_CPPv4N5riner6DeviceE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>device bundle for usage by <code class="docutils literal notranslate"><span class="pre">AlgoImpls</span></code> </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner6Device6DeviceERK8DeviceIdRK12AlgoSettings6size_t">
<span id="_CPPv3N5riner6Device6DeviceERK8DeviceIdRK12AlgoSettings6size_t"></span><span id="_CPPv2N5riner6Device6DeviceERK8DeviceIdRK12AlgoSettings6size_t"></span><span id="riner::Device::Device__DeviceIdCR.AlgoSettingsCR.s"></span><span class="target" id="structriner_1_1Device_1a05da559c8f4d9c8d4d0f565209873869"></span><code class="sig-name descname">Device</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner8DeviceIdE" title="riner::DeviceId">DeviceId</a> &amp;<em>_id</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5riner12AlgoSettingsE" title="riner::AlgoSettings">AlgoSettings</a> &amp;<em>_settings</em>, size_t <em>_deviceIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner6Device6DeviceERK8DeviceIdRK12AlgoSettings6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1Device"><span class="std std-ref"><span class="pre">Device</span></span></a></code> for passing device related information and handles to <code class="docutils literal notranslate"><span class="pre">AlgoImpl</span></code>s via <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1AlgoConstructionArgs"><span class="std std-ref"><span class="pre">AlgoConstructionArgs</span></span></a></code> <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_id</span></code>: the generic <a class="reference internal" href="#classriner_1_1DeviceId"><span class="std std-ref">DeviceId</span></a> of the <a class="reference internal" href="#structriner_1_1Device"><span class="std std-ref">Device</span></a> that is supposed to be represented </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_settings</span></code>: the <a class="reference internal" href="#structriner_1_1AlgoSettings"><span class="std std-ref">AlgoSettings</span></a> for this device under the currently running device profile/AlgoImpl combination </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_deviceIndex</span></code>: the index of the device’s id in <code class="docutils literal notranslate"><a class="reference internal" href="#classriner_1_1ComputeModule_1a1d98c39c1f21cd20e4f6774683742487"><span class="std std-ref"><span class="pre">ComputeModule::getAllDeviceIds()</span></span></a></code> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N5riner6Device7recordsE">
<span id="_CPPv3N5riner6Device7recordsE"></span><span id="_CPPv2N5riner6Device7recordsE"></span><span id="riner::Device::records__DeviceRecords"></span><span class="target" id="structriner_1_1Device_1a8eca65666477e711dc9e94d8e86e69d5"></span><a class="reference internal" href="#_CPPv4N5riner13DeviceRecordsE" title="riner::DeviceRecords">DeviceRecords</a> <code class="sig-name descname">records</code><a class="headerlink" href="#_CPPv4N5riner6Device7recordsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>report per-device hashrate etc, via this object from within an <code class="docutils literal notranslate"><span class="pre">AlgoImpl</span></code> </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N5riner6Device3apiE">
<span id="_CPPv3N5riner6Device3apiE"></span><span id="_CPPv2N5riner6Device3apiE"></span><span id="riner::Device::api__std::unique_ptr:GpuApi:"></span><span class="target" id="structriner_1_1Device_1a157d71418f88c4c482c6872ad2d1d774"></span>std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner6GpuApiE" title="riner::GpuApi">GpuApi</a>&gt; <code class="sig-name descname">api</code><a class="headerlink" href="#_CPPv4N5riner6Device3apiE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>interact with an optional <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a>. May be nullptr if no <a class="reference internal" href="#classriner_1_1GpuApi"><span class="std std-ref">GpuApi</span></a> could be initialized. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="shutdownstate">
<h2>ShutdownState<a class="headerlink" href="#shutdownstate" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner13ShutdownStateE">
<span id="_CPPv3N5riner13ShutdownStateE"></span><span id="_CPPv2N5riner13ShutdownStateE"></span><span id="riner::ShutdownState"></span><span class="target" id="structriner_1_1ShutdownState"></span><em class="property">struct </em><code class="sig-name descname">ShutdownState</code><a class="headerlink" href="#_CPPv4N5riner13ShutdownStateE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Responds to CTRL+C signal and shuts down the <a class="reference internal" href="#classriner_1_1Application"><span class="std std-ref">Application</span></a> while giving it a little grace period to join all the threads and close all connections. created in Main.cpp </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner13ShutdownState23shutdownWithTimeoutFuncEi">
<span id="_CPPv3N5riner13ShutdownState23shutdownWithTimeoutFuncEi"></span><span id="_CPPv2N5riner13ShutdownState23shutdownWithTimeoutFuncEi"></span><span id="riner::ShutdownState::shutdownWithTimeoutFunc__i"></span><span class="target" id="structriner_1_1ShutdownState_1a4dbfaf6c3441bbb68730afa534157a34"></span>void <code class="sig-name descname">shutdownWithTimeoutFunc</code><span class="sig-paren">(</span>int <em>signum</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13ShutdownState23shutdownWithTimeoutFuncEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>runs on separate thread that communicates with the main() function and exits if the application does not close before a certain timeout </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13ShutdownState18launchShutdownTaskEi">
<span id="_CPPv3N5riner13ShutdownState18launchShutdownTaskEi"></span><span id="_CPPv2N5riner13ShutdownState18launchShutdownTaskEi"></span><span id="riner::ShutdownState::launchShutdownTask__i"></span><span class="target" id="structriner_1_1ShutdownState_1a7204fa031055cfb714e5fb104367be68"></span>void <code class="sig-name descname">launchShutdownTask</code><span class="sig-paren">(</span>int <em>signum</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13ShutdownState18launchShutdownTaskEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Launches the shutdown thread which gives the application a little grace period to shutdown and also unblocks the <code class="docutils literal notranslate"><a class="reference internal" href="#structriner_1_1ShutdownState_1a78f829be375aa1198165ca6e30cf7d1b"><span class="std std-ref"><span class="pre">waitUntilShutdownRequested()</span></span></a></code> function which the main thread in <code class="docutils literal notranslate"><span class="pre">main()</span></code> is waiting in. called by the sigintHandler in Main.cpp. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">signum</span></code>: the signum argument of the signal handler that calls this function </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13ShutdownState26waitUntilShutdownRequestedEv">
<span id="_CPPv3N5riner13ShutdownState26waitUntilShutdownRequestedEv"></span><span id="_CPPv2N5riner13ShutdownState26waitUntilShutdownRequestedEv"></span><span id="riner::ShutdownState::waitUntilShutdownRequested"></span><span class="target" id="structriner_1_1ShutdownState_1a78f829be375aa1198165ca6e30cf7d1b"></span>void <code class="sig-name descname">waitUntilShutdownRequested</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13ShutdownState26waitUntilShutdownRequestedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>blocks until <a class="reference internal" href="#structriner_1_1ShutdownState_1a7204fa031055cfb714e5fb104367be68"><span class="std std-ref">launchShutdownTask()</span></a> is called </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5riner13ShutdownState19confirmAppHasClosedEv">
<span id="_CPPv3N5riner13ShutdownState19confirmAppHasClosedEv"></span><span id="_CPPv2N5riner13ShutdownState19confirmAppHasClosedEv"></span><span id="riner::ShutdownState::confirmAppHasClosed"></span><span class="target" id="structriner_1_1ShutdownState_1aa8a5ab7414c6743c7da7f9f61968eeb8"></span>void <code class="sig-name descname">confirmAppHasClosed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner13ShutdownState19confirmAppHasClosedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>called by the main thread to communicate to the Shutdown task thread that the <code class="docutils literal notranslate"><span class="pre">Applicatoin</span></code> successfully closed, which causes the Shutdown task to finish and join. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="commandlineargs">
<h2>CommandLineArgs<a class="headerlink" href="#commandlineargs" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner15CommandLineArgsE">
<span id="_CPPv3N5riner15CommandLineArgsE"></span><span id="_CPPv2N5riner15CommandLineArgsE"></span><span id="riner::CommandLineArgs"></span><span class="target" id="structriner_1_1CommandLineArgs"></span><em class="property">struct </em><code class="sig-name descname">CommandLineArgs</code><a class="headerlink" href="#_CPPv4N5riner15CommandLineArgsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>command line argument wrapper struct. Used as return value for for <code class="docutils literal notranslate"><span class="pre">copyArgsAndExpandSingleDashCombinedArgs</span></code> </p>
</dd></dl>

</div>
<div class="section" id="haspowtypeethash">
<h2>HasPowTypeEthash<a class="headerlink" href="#haspowtypeethash" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner16HasPowTypeEthashE">
<span id="_CPPv3N5riner16HasPowTypeEthashE"></span><span id="_CPPv2N5riner16HasPowTypeEthashE"></span><span id="riner::HasPowTypeEthash"></span><span class="target" id="structriner_1_1HasPowTypeEthash"></span><em class="property">struct </em><code class="sig-name descname">HasPowTypeEthash</code><a class="headerlink" href="#_CPPv4N5riner16HasPowTypeEthashE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Subclassed by <a class="reference internal" href="#classriner_1_1WorkEthash"><span class="std std-ref">riner::WorkEthash</span></a>, <a class="reference internal" href="#classriner_1_1WorkSolutionEthash"><span class="std std-ref">riner::WorkSolutionEthash</span></a></p>
</dd></dl>

</div>
<div class="section" id="poolconstructionargs">
<h2>PoolConstructionArgs<a class="headerlink" href="#poolconstructionargs" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner20PoolConstructionArgsE">
<span id="_CPPv3N5riner20PoolConstructionArgsE"></span><span id="_CPPv2N5riner20PoolConstructionArgsE"></span><span id="riner::PoolConstructionArgs"></span><span class="target" id="structriner_1_1PoolConstructionArgs"></span><em class="property">struct </em><code class="sig-name descname">PoolConstructionArgs</code><a class="headerlink" href="#_CPPv4N5riner20PoolConstructionArgsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Args passed into every <a class="reference internal" href="#classriner_1_1Pool"><span class="std std-ref">Pool</span></a> subclass ctor If you want to add args to every pool’s ctor, add them to this struct instead. </p>
<p>don’t confuse this with Config::Pool. <a class="reference internal" href="#structriner_1_1PoolConstructionArgs"><span class="std std-ref">PoolConstructionArgs</span></a> may be used to pass refs to other subsystems in the future (e.g. io_service?) </p>
</dd></dl>

</div>
<div class="section" id="pooljob">
<h2>PoolJob<a class="headerlink" href="#pooljob" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner7PoolJobE">
<span id="_CPPv3N5riner7PoolJobE"></span><span id="_CPPv2N5riner7PoolJobE"></span><span id="riner::PoolJob"></span><span class="target" id="structriner_1_1PoolJob"></span><em class="property">struct </em><code class="sig-name descname">PoolJob</code><a class="headerlink" href="#_CPPv4N5riner7PoolJobE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Subclasses store all necessary pool and protocol related data. </p>
<p>Subclassed by <a class="reference internal" href="#structriner_1_1DummyPoolJob"><span class="std std-ref">riner::DummyPoolJob</span></a>, <a class="reference internal" href="#structriner_1_1EthashStratumJob"><span class="std std-ref">riner::EthashStratumJob</span></a>, <a class="reference internal" href="#structriner_1_1GrinStratumJob"><span class="std std-ref">riner::GrinStratumJob</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner7PoolJob8makeWorkEv">
<span id="_CPPv3N5riner7PoolJob8makeWorkEv"></span><span id="_CPPv2N5riner7PoolJob8makeWorkEv"></span><span id="riner::PoolJob::makeWork"></span><span class="target" id="structriner_1_1PoolJob_1a19c0464f89fe0d8eaf36f7d6f49d600b"></span><em class="property">virtual</em> unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">makeWork</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5riner7PoolJob8makeWorkEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a>(-subclass) object with a unique solutionspace which can be handed out to the AlgoImpl.</p>
<p>IMPORTANT: <a class="reference internal" href="#structriner_1_1PoolJob_1a19c0464f89fe0d8eaf36f7d6f49d600b"><span class="std std-ref">makeWork()</span></a> is usually called by mechanisms that run in various threads which hold a lock while calling into <a class="reference internal" href="#structriner_1_1PoolJob_1a19c0464f89fe0d8eaf36f7d6f49d600b"><span class="std std-ref">makeWork()</span></a>. Be cautious if you need to acquire any locks within <a class="reference internal" href="#structriner_1_1PoolJob_1a19c0464f89fe0d8eaf36f7d6f49d600b"><span class="std std-ref">makeWork()</span></a>.</p>
<p>If used by a <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a>, makeWork is always called sequentially while a lock is held (so no concurrent invocations of <a class="reference internal" href="#structriner_1_1PoolJob_1a19c0464f89fe0d8eaf36f7d6f49d600b"><span class="std std-ref">makeWork()</span></a> on the same <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> can exist).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>: a unique_ptr to a subclass of <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> that was created by this function, based on this <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="haspowtypedummy">
<h2>HasPowTypeDummy<a class="headerlink" href="#haspowtypedummy" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner15HasPowTypeDummyE">
<span id="_CPPv3N5riner15HasPowTypeDummyE"></span><span id="_CPPv2N5riner15HasPowTypeDummyE"></span><span id="riner::HasPowTypeDummy"></span><span class="target" id="structriner_1_1HasPowTypeDummy"></span><em class="property">struct </em><code class="sig-name descname">HasPowTypeDummy</code><a class="headerlink" href="#_CPPv4N5riner15HasPowTypeDummyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Subclassed by <a class="reference internal" href="#structriner_1_1WorkDummy"><span class="std std-ref">riner::WorkDummy</span></a>, <a class="reference internal" href="#structriner_1_1WorkSolutionDummy"><span class="std std-ref">riner::WorkSolutionDummy</span></a></p>
</dd></dl>

</div>
<div class="section" id="workdummy">
<h2>WorkDummy<a class="headerlink" href="#workdummy" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner9WorkDummyE">
<span id="_CPPv3N5riner9WorkDummyE"></span><span id="_CPPv2N5riner9WorkDummyE"></span><span id="riner::WorkDummy"></span><span class="target" id="structriner_1_1WorkDummy"></span><em class="property">struct </em><code class="sig-name descname">WorkDummy</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>, <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner15HasPowTypeDummyE" title="riner::HasPowTypeDummy">HasPowTypeDummy</a><a class="headerlink" href="#_CPPv4N5riner9WorkDummyE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="worksolutiondummy">
<h2>WorkSolutionDummy<a class="headerlink" href="#worksolutiondummy" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner17WorkSolutionDummyE">
<span id="_CPPv3N5riner17WorkSolutionDummyE"></span><span id="_CPPv2N5riner17WorkSolutionDummyE"></span><span id="riner::WorkSolutionDummy"></span><span class="target" id="structriner_1_1WorkSolutionDummy"></span><em class="property">struct </em><code class="sig-name descname">WorkSolutionDummy</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner12WorkSolutionE" title="riner::WorkSolution">WorkSolution</a>, <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner15HasPowTypeDummyE" title="riner::HasPowTypeDummy">HasPowTypeDummy</a><a class="headerlink" href="#_CPPv4N5riner17WorkSolutionDummyE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="ethashstratumjob">
<h2>EthashStratumJob<a class="headerlink" href="#ethashstratumjob" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner16EthashStratumJobE">
<span id="_CPPv3N5riner16EthashStratumJobE"></span><span id="_CPPv2N5riner16EthashStratumJobE"></span><span id="riner::EthashStratumJob"></span><span class="target" id="structriner_1_1EthashStratumJob"></span><em class="property">struct </em><code class="sig-name descname">EthashStratumJob</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a><a class="headerlink" href="#_CPPv4N5riner16EthashStratumJobE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> for <a class="reference internal" href="#classriner_1_1PoolEthashStratum"><span class="std std-ref">PoolEthashStratum</span></a>’s <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a> </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner16EthashStratumJob8makeWorkEv">
<span id="_CPPv3N5riner16EthashStratumJob8makeWorkEv"></span><span id="_CPPv2N5riner16EthashStratumJob8makeWorkEv"></span><span id="riner::EthashStratumJob::makeWork"></span><span class="target" id="structriner_1_1EthashStratumJob_1a85c4b72eb1b8e0baad288959898da836"></span>std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">makeWork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner16EthashStratumJob8makeWorkEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a>(-subclass) object with a unique solutionspace which can be handed out to the AlgoImpl.</p>
<p>IMPORTANT: <a class="reference internal" href="#structriner_1_1EthashStratumJob_1a85c4b72eb1b8e0baad288959898da836"><span class="std std-ref">makeWork()</span></a> is usually called by mechanisms that run in various threads which hold a lock while calling into <a class="reference internal" href="#structriner_1_1EthashStratumJob_1a85c4b72eb1b8e0baad288959898da836"><span class="std std-ref">makeWork()</span></a>. Be cautious if you need to acquire any locks within <a class="reference internal" href="#structriner_1_1EthashStratumJob_1a85c4b72eb1b8e0baad288959898da836"><span class="std std-ref">makeWork()</span></a>.</p>
<p>If used by a <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a>, makeWork is always called sequentially while a lock is held (so no concurrent invocations of <a class="reference internal" href="#structriner_1_1EthashStratumJob_1a85c4b72eb1b8e0baad288959898da836"><span class="std std-ref">makeWork()</span></a> on the same <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> can exist).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>: a unique_ptr to a subclass of <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> that was created by this function, based on this <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="grinstratumjob">
<h2>GrinStratumJob<a class="headerlink" href="#grinstratumjob" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner14GrinStratumJobE">
<span id="_CPPv3N5riner14GrinStratumJobE"></span><span id="_CPPv2N5riner14GrinStratumJobE"></span><span id="riner::GrinStratumJob"></span><span class="target" id="structriner_1_1GrinStratumJob"></span><em class="property">struct </em><code class="sig-name descname">GrinStratumJob</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a><a class="headerlink" href="#_CPPv4N5riner14GrinStratumJobE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner14GrinStratumJob8makeWorkEv">
<span id="_CPPv3N5riner14GrinStratumJob8makeWorkEv"></span><span id="_CPPv2N5riner14GrinStratumJob8makeWorkEv"></span><span id="riner::GrinStratumJob::makeWork"></span><span class="target" id="structriner_1_1GrinStratumJob_1adf4aab65bd93d07fd831d46e3a4c2e9d"></span>std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">makeWork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner14GrinStratumJob8makeWorkEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a>(-subclass) object with a unique solutionspace which can be handed out to the AlgoImpl.</p>
<p>IMPORTANT: <a class="reference internal" href="#structriner_1_1GrinStratumJob_1adf4aab65bd93d07fd831d46e3a4c2e9d"><span class="std std-ref">makeWork()</span></a> is usually called by mechanisms that run in various threads which hold a lock while calling into <a class="reference internal" href="#structriner_1_1GrinStratumJob_1adf4aab65bd93d07fd831d46e3a4c2e9d"><span class="std std-ref">makeWork()</span></a>. Be cautious if you need to acquire any locks within <a class="reference internal" href="#structriner_1_1GrinStratumJob_1adf4aab65bd93d07fd831d46e3a4c2e9d"><span class="std std-ref">makeWork()</span></a>.</p>
<p>If used by a <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a>, makeWork is always called sequentially while a lock is held (so no concurrent invocations of <a class="reference internal" href="#structriner_1_1GrinStratumJob_1adf4aab65bd93d07fd831d46e3a4c2e9d"><span class="std std-ref">makeWork()</span></a> on the same <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> can exist).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>: a unique_ptr to a subclass of <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> that was created by this function, based on this <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="dummypooljob">
<h2>DummyPoolJob<a class="headerlink" href="#dummypooljob" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5riner12DummyPoolJobE">
<span id="_CPPv3N5riner12DummyPoolJobE"></span><span id="_CPPv2N5riner12DummyPoolJobE"></span><span id="riner::DummyPoolJob"></span><span class="target" id="structriner_1_1DummyPoolJob"></span><em class="property">struct </em><code class="sig-name descname">DummyPoolJob</code> : <em class="property">public</em> riner::<a class="reference internal" href="#_CPPv4N5riner7PoolJobE" title="riner::PoolJob">PoolJob</a><a class="headerlink" href="#_CPPv4N5riner12DummyPoolJobE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5riner12DummyPoolJob8makeWorkEv">
<span id="_CPPv3N5riner12DummyPoolJob8makeWorkEv"></span><span id="_CPPv2N5riner12DummyPoolJob8makeWorkEv"></span><span id="riner::DummyPoolJob::makeWork"></span><span class="target" id="structriner_1_1DummyPoolJob_1a72cb8478578e8d8e54ca0187de976b5d"></span>std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5riner4WorkE" title="riner::Work">Work</a>&gt; <code class="sig-name descname">makeWork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5riner12DummyPoolJob8makeWorkEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a>(-subclass) object with a unique solutionspace which can be handed out to the AlgoImpl.</p>
<p>IMPORTANT: <a class="reference internal" href="#structriner_1_1DummyPoolJob_1a72cb8478578e8d8e54ca0187de976b5d"><span class="std std-ref">makeWork()</span></a> is usually called by mechanisms that run in various threads which hold a lock while calling into <a class="reference internal" href="#structriner_1_1DummyPoolJob_1a72cb8478578e8d8e54ca0187de976b5d"><span class="std std-ref">makeWork()</span></a>. Be cautious if you need to acquire any locks within <a class="reference internal" href="#structriner_1_1DummyPoolJob_1a72cb8478578e8d8e54ca0187de976b5d"><span class="std std-ref">makeWork()</span></a>.</p>
<p>If used by a <a class="reference internal" href="#classriner_1_1WorkQueue"><span class="std std-ref">WorkQueue</span></a>, makeWork is always called sequentially while a lock is held (so no concurrent invocations of <a class="reference internal" href="#structriner_1_1DummyPoolJob_1a72cb8478578e8d8e54ca0187de976b5d"><span class="std std-ref">makeWork()</span></a> on the same <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> can exist).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>: a unique_ptr to a subclass of <a class="reference internal" href="#classriner_1_1Work"><span class="std std-ref">Work</span></a> that was created by this function, based on this <a class="reference internal" href="#structriner_1_1PoolJob"><span class="std std-ref">PoolJob</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="function.html" class="btn btn-neutral float-right" title="Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="introduction.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Genesis Mining

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>