//
//

#pragma once

#include <src/pool/Pool.h>
#include <src/pool/WorkDummy.h>
#include <src/config/Config.h>
#include <src/util/LockUtils.h>
#include <src/common/Pointers.h>
#include <queue>
#include <future>
#include <list>
#include <atomic>
#include <src/network/JsonRpcUtil.h>
#include "WorkQueue.h"
#include "DummyTestPoolServer.h" //a mock server to see this pool in action

namespace riner {

    class PoolDummy : public Pool {
    public:
        explicit PoolDummy(const PoolConstructionArgs &);
        ~PoolDummy() override;

        void expireJobs() override;
        void clearJobs() override;

    private:
        DummyTestPoolServer mock_server; //this is just here for tutorial purposes. Its a server that simulates a dummy pool on localhost, so that you can see the PoolDummy code in action.

        WorkQueue queue {2, 4}; //the numbers (2, 4) provided are lower than default to make the logs less verbose in this demonstration. See the WorkQueue docs for more info.

        // Pool interface
        bool isExpiredJob(const PoolJob &job) override;
        unique_ptr<Work> tryGetWorkImpl() override;
        void submitSolutionImpl(unique_ptr<WorkSolution>) override;
        void onDeclaredDead() override;

        jrpc::JsonRpcUtil io{"PoolDummy"}; //io utility object, "Pool Dummy" will show up in the thread name section in logs coming from the io-thread generated by this object
        CxnHandle _cxn; //io connection to pool (used together with io object above)

        void onConnected(CxnHandle cxn); //see in tryConnect() why this is needed
        void tryConnect();

        bool acceptWorkMessages = false; //at the beginning we don't accept work messages yet

        void onMiningNotify (const nl::json &j); //called when we receive a mining.notify message
    };

    //this class is a bit tricky
    //a PoolJob is like a factory for Work objects, therefore the important method here is "makeWork"
    //a PoolJob can expire, that functionality is handled for you by the PoolJob base class though.
    struct DummyPoolJob : public PoolJob {

        //below are all the
        const std::string jobId;
        double difficulty = 0;
        WorkDummy workTemplate; //the word "template" is not meant in a c++ template<> sense here, but rather this is the work struct we copy and modify to hand out actual work in the work queue. (see makeWork() below)

        std::unique_ptr<Work> makeWork() override { //makeWork is called from another thread (usually the WorkQueue thread).
            //in here, do whatever is necessary to define the solution-space for
            //a WorkDummy instance so that the work of two instances never overlaps.

            VLOG(2) << "DummyPoolJob is making one WorkDummy instance from the workTemplate to refill the WorkQueue";

            uint64_t single_work_range = 1234567; //made up number, this is just a dummy

            workTemplate.nonce_begin += single_work_range;
            workTemplate.nonce_end = workTemplate.nonce_begin + single_work_range;

            //we modified the workTemplate, now we copy it and move the copy out.
            return make_unique<WorkDummy>(workTemplate); //invoke WorkDummy's copy constructor
        }

        //the PoolJob base class demands a weak_ptr to the Pool (which you can get from a Pool via pool->_this`)
        explicit DummyPoolJob(const std::weak_ptr<Pool> &pool, std::string id)
        : PoolJob(pool)
        , jobId(std::move(id)) {
        }

    };

}
